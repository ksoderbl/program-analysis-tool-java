// -*- java -*-
/**
 * Parser generator file for ARM assembler generated by GCC.
 *
 * @author Juha Tukkinen
 * @author Mikko Reinikainen
 * @author Kristian SÃ¶derblom
 */
options {
    STATIC=false;
}

PARSER_BEGIN(ARMGasParser)

package arm.gas;

import input.Input;
import input.InputLineObject;
import instr.Operand;
import arm.instr.*;
import machine.Machine;
import machine.Register;
import machine.Registers;
import program.Label;
import stabs.Stab;
import stabs.StabParser;
import arm.*;
import main.*;
import misc.*;
import pseudoOp.*;

import java.util.List;
import java.util.ArrayList;
import java.io.*;

public class ARMGasParser {

    private static final long serialVersionUID = 1L;

    private Input input;
    private List<InputLineObject> inputLines;
    private Machine machine;
    private Registers registers;
    private String filename;
    private UserOptions useroptions;

    public ARMGasParser(FileInputStream fin, Input input, UserOptions useroptions,
                        Machine machine) {
        this(fin);
        this.input = input;
        this.inputLines = input.getInputLines();
        this.filename = input.getFileName();
        this.machine = machine;
        this.registers = machine.getRegisters();
        this.useroptions = useroptions;
        Main.info("Parsing file '" + filename + "'.");
    }

    /**
     * @return value of a decimal or hexadecimal String as a long
     */
    public static long parseNum(String num) {
        if ((num.length() > 2)
            && (num.charAt(0) == '0') 
            && ((num.charAt(1) == 'x')
                || (num.charAt(1) == 'X'))) {
            return Long.parseLong(num.substring(2), 16);
        } else {
            return Long.parseLong(num);
        }
    }
}

PARSER_END(ARMGasParser)

SKIP : { " " | "\t" | "\n" | "\r" }

SPECIAL_TOKEN : /* Comments start with "@" */
{
    <SINGLE_LINE_COMMENT: "@" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN : /* Instructions for ARM architecture v4T, no CP support */
{
  <MOV: "mov" <COND> ("s")? > 
| <MVN: "mvn" <COND> ("s")? >
| <MRS: "mrs" <COND> >
| <MSR: "msr" <COND> >
| <ADD: "add" <COND> ("s")? >
| <ADC: "adc" <COND> ("s")? >
| <SUB: "sub" <COND> ("s")? >
| <SBC: "sbc" <COND> ("s")? >
| <RSB: "rsb" <COND> ("s")? >
| <RSC: "rsc" <COND> ("s")? >
| <MUL: "mul" <COND> ("s")? >
| <MLA: "mla" <COND> ("s")? >
| <UMULL: "umull" <COND> ("s")? >
| <UMLAL: "umlal" <COND> ("s")? >
| <SMULL: "smull" <COND> ("s")? >
| <SMLAL: "smlal" <COND> ("s")? >
| <CLZ: "clz" <COND> >
| <TST: "tst" <COND> >
| <TEQ: "teq" <COND> >
| <AND: "and" <COND> ("s")? >
| <EOR: "eor" <COND> ("s")? >
| <ORR: "orr" <COND> ("s")? >
| <BIC: "bic" <COND> ("s")? >
| <CMP: "cmp" <COND> >
| <CMN: "cmn" <COND> >
| <NOP: "nop">
| <B: "b" <COND> >
| <BL: "bl" <COND> >
| <BX: "bx" <COND> >
| <LDR: "ldr" <COND>  >
| <LDRT: "ldr" <COND> "t" >
| <LDRB: "ldr" <COND> "b" >
| <LDRBT: "ldr" <COND> "bt" >
| <LDRSB: "ldr" <COND> "sb" >
| <LDRH: "ldr" <COND> "h" >
| <LDRSH: "ldr" <COND> "sh" >
| <LDM: "ldm" <COND> <ADDR4> >
| <STR: "str" <COND>  >
| <STRT: "str" <COND> "t" >
| <STRB: "str" <COND> "b" >
| <STRBT: "str" <COND> "bt" >
| <STRH: "str" <COND> "h" >
| <STM: "stm" <COND> <ADDR4> >
| <SWP: "swp" <COND> ("b")? >
| <SWI: "swi" <COND>  >
| <#COND: ("eq"|"ne"|"cs"|"hs"|"cc"|"lo"|"mi"|"pl"|"vs"|
               "vc"|"hi"|"ls"|"ge"|"lt"|"gt"|"le"|"al")? >
| <#ADDR4: ("ia"|"ib"|"da"|"db"|"fd"|"ed"|"fa"|"ea") >
| <LSL: "lsl">
| <LSR: "lsr">
| <ASL: "asl"> // zzz doesn't exist in the ARM specs
| <ASR: "asr">
| <ROR: "ror">
| <RRX: "rrx">
| <CPSR: "cpsr" ("_" ("c"|"f"|"s"|"x")* )? >
| <SPSR: "spsr" ("_" ("c"|"f"|"s"|"x")* )? >
}

TOKEN : /*  GCC specific operations: */
{ 
  <ADR: "adr">  // zzz
/* pseudo operations */
| <ALIGN: ".align" >
| <ASCII: ".ascii" >
| <BSS: ".bss" >
| <BYTE: ".byte" >
| <CODE: ".code" >
| <COMM: ".comm" >
| <DATA: ".data" >
| <FILE: ".file" >
| <FOURBYTE: ".4byte" >
| <GLOBAL: ".global" >
| <IDENT: ".ident" >
| <LOC: ".loc" >
| <LONG: ".long" >
| <P2ALIGN: ".p2align" >
| <SECTION: ".section" >
| <SHORT: ".short" >
| <SIZE: ".size" >
| <SLEB128: ".sleb128" >
| <SPACE: ".space" >
| <TEXT: ".text" >
| <TWOBYTE: ".2byte" >
| <TYPE: ".type" >
| <ULEB128: ".uleb128" >
| <WORD: ".word" >
/*  stabs debugging information format: */
| <STABS: ".stabs" >
| <STABN: ".stabn" >
| <STABD: ".stabd" >
}

TOKEN : /* Literals and separators */
{
  <INTEGER_LITERAL:
    <DECIMAL_LITERAL> 
  | <HEX_LITERAL> >
| <#DECIMAL_LITERAL: "#" ("+"|"-")? ("0" | (["1"-"9"] (["0"-"9"])* )) >
| <#HEX_LITERAL: "#&" (["0"-"9","a"-"f","A"-"F"])+ >
| <COLON: ":">
| <PERCENT: "%">
| <LPAREN: "(" >
| <RPAREN: ")" >
| <LBRACKET: "[" >
| <RBRACKET: "]" >
| <LBRACE: "{" >
| <RBRACE: "}" >
| <COMMA: "," >
| <SEMICOLON: ";" >
| <PLUS: "+" >
| <MINUS: "-" >
| <TIMES: "*" >
| <EXCLAMATION: "!" >
| <HAT : "^" >
| <UNDERSCORE: "_">
| <NUM: <DECIMAL_NUM> | <HEX_NUM> >
| <#DECIMAL_NUM: ("-")? ("0" | (["1"-"9"] (["0"-"9"])* )) >
| <#HEX_NUM: "0x" (["0"-"9","a"-"f","A"-"F"])* >
| <REG: ("r" ("0" | (["1"-"9"] (["0"-"9"])* ))
         | "sp" | "ip" | "fp" | "lr" | "pc" | "sl") >
| <ID: ("."|"_"|"$"|["a"-"z"]|["A"-"Z"])
         ("."|"_"|["a"-"z"]|["A"-"Z"]|["0"-"9"])* >
| <QUOTED_STRING: "\"" (~["\""])* "\"">
}

/*****************************
 * GCC ARM Assembler grammar *
 *****************************/

InputLineObject SourceLine() :
{
    Label l;
    PseudoOp pop;
    InputLineObject next, node;
}
{
    node = Instr() {
        return node;
    }
    | l = Label() <COLON> {
        return l;
    }
    | pop = PseudoOp() {
        return pop;
    }
}

void ParseInput():
{
    InputLineObject next;
}
{
    (next=SourceLine()
        {
            inputLines.add(next);
        }
     )*
        <EOF>
}

ARMInstruction Instr():
{ 
    ARMInstruction i = null; 
}
{
    (i = Arithmetic() | i = Misc() | i = Branch() | i = BranchAndLink()) {
        if (i != null) {
            //System.out.println("INSTR '"+i+"' defs = " + i.getDefs() + " uses = " + i.getUses());
            if (i.getDefs() != null
                && i.getDefs().contains(registers.r[ARMMachine.PC])) {
                //System.out.println("  --> instruction defines pc");

                if (i.getUses() != null
                    && (i.getUses().contains(registers.r[ARMMachine.LR])
                        ||i.getUses().contains(registers.r[ARMMachine.SP]))) {
                    i.setReturn(i.isConditional());
                    //Main.warn("instr " + i + " is a " 
                    //              + (i.isConditional() ? "conditional " : "")
                    //              + "return");

                }

                    //System.out.println("  --> instruction uses lr");
                
            }



            //System.err.println("instr: " + i.toString());
        } else { 
            // should not happen in the final front end
            Main.warn("unrecognized instruction on line " + i.getLine());
        }
        return i;
    }
}

PseudoOp PseudoOp() :
{
    PseudoOp pop;
    String id, type;
    long len, align, value;
    String fileName, string;
    Expression expr;
    ArrayList<Object> list = new ArrayList<Object>();
}
{
    <FILE> [Num()] fileName = QuotedString() {
        return new FilePseudoOp(fileName);
    }
    | <TEXT> {
        return new TextPseudoOp();
    }
    | <ALIGN> align = Num() {
        return new AlignPseudoOp(align);
    }
    | <GLOBAL> id = Id() {
        return new GlobalPseudoOp(id);
    }
    | <TYPE> id = Id() <COMMA> [<PERCENT>] type = Id() {
        return new TypePseudoOp(id, type);
    }
    | <SIZE> id = Id() <COMMA> expr = Expr() {
        return new SizePseudoOp(id, expr);
    }
    | <SPACE> value = Num() {
        return new SpacePseudoOp(value);
    }
    | <IDENT> string = QuotedString() {
        return new IdentPseudoOp(string);
    }
    | <BSS> {
        return new BssPseudoOp();
    }
    | <DATA> {
        return new DataPseudoOp();
    }
    | <ASCII> string = QuotedString() {
        return new AsciiPseudoOp(string);
    }
    | <WORD> expr = Expr() {
        list.add(expr);
        return new WordPseudoOp(list);
    }
    | <BYTE> expr = Expr() {
        return new BytePseudoOp(expr);
    }
    | <SHORT> value = Num() {
        return new ShortPseudoOp(value);
    }
    | <SECTION> id = Id()
           [<COMMA> <QUOTED_STRING> <COMMA> <PERCENT> <ID> [<COMMA> <NUM>]] {
        return new SectionPseudoOp(id);
    }
    | <COMM> id = Id() <COMMA> len = Num() <COMMA> align = Num()
           [<COMMA> Num() <COMMA> Num()] {
        /*PseudoOps.addCommBlock(program,id,len,align);*/
        return new CommPseudoOp(id, len, align);
    }
    | pop = Stabs() {
        return pop;
    }
}

/* stabs debugging information format */
PseudoOp Stabs() :
{
    String string;
    long type;
    long other;
    long desc;
    Expression value;
}
{
    <STABS> // stab string
    string = QuotedString() <COMMA> 
    type = Num() <COMMA> 
    other = Num() <COMMA>
    desc = Num() <COMMA>
    value = Expr() {
        return StabParser.parse(string, type, other, desc, value);
    }
    | <STABN> // stab number
    type = Num() <COMMA> 
    other = Num() <COMMA>
    desc = Num() <COMMA>
    value = Expr() {
        return StabParser.parse(null, type, other, desc, value);
    }
    | <STABD>  // stab dot
    type = Num() <COMMA> 
    other = Num() <COMMA>
    desc = Num() {
        return StabParser.parse(null, type, other, desc, null);
    }
}

String Id() :
{
    Token id;
    String l;
}
{
    id=<ID> {
        l = id.image;
        // kps hack: to get unique file internal labels,
        // suffix the file name after the label name.
        //if (l.startsWith(".L")) {
        //    l = l + "(" + filename + ")";
        //}
        return l;
    }
}

Label Label() :
{
    String s;
    Label l;
    Token t;
}
{
    t=<ID> {
        s = t.image;
        //if (s.startsWith(".L")) {
        //    s = s + "(" + filename + ")";
        //}
        l = new Label(s, input);
        l.setInput(input); l.setLine(t.beginLine);
        return l;
    }

}

Expression Expr() :
{
    Expression expr, expr1, expr2;
    String id = null;
    long val1 = 0, val2 = 0;
    Token o;
}
{
    LOOKAHEAD(3) (val1 = Num() | id = Id()) (o = <MINUS> | o = <PLUS> | o = <TIMES>) expr2 = Expr() {
        if (id == null) {
            expr1 = new NumExpression(val1);
        } else {
            expr1 = new IdExpression(id);
        }

        if (o.image.equals("+")
            || o.image.equals("-")
            || o.image.equals("*")) {
            return new BinaryExpression(expr1, o.image, expr2);
        } else {        
            Main.warn("error on line " + o.beginLine
                      + ": unrecognized operation '" + o.image + "'");
            return null;
        }
    }
    | <LPAREN> expr = Expr() <RPAREN> {
        return expr;
    }
    | val1 = Num() {
        return new NumExpression(val1);
    }
    | id = Id() {
        return new IdExpression(id);
    }
}

ARMRegister Reg() :
{
    Token t;
    int regNum;
}
{
    t=<REG> {
        if (t.image.equals("sp")) {
            regNum = ARMMachine.SP;
        } else if (t.image.equals("ip")) {
            regNum = ARMMachine.IP;
        } else if (t.image.equals("fp")) {
            regNum = ARMMachine.FP;
        } else if (t.image.equals("lr")) {
            regNum = ARMMachine.LR;
        } else if (t.image.equals("pc")) {
            regNum = ARMMachine.PC;
        } else if (t.image.equals("sl")) {
            regNum = ARMMachine.SL;
        } else {
            regNum = Integer.parseInt(t.image.substring(1));
        }
        return (ARMRegister)registers.r[regNum];
    }
}

String QuotedString() :
{
    Token t;
}
{
    t = <QUOTED_STRING> {
        return t.image.substring(1, t.image.length()-1);
    }
}

long Num() :
{ 
    Token t;
}
{
    t = <NUM> {
        return parseNum(t.image);
    }
}

Integer Int() :
{
    Token t;
    int intVal;
}
{
    t=<INTEGER_LITERAL> {
        if (t.image.substring(1, 1).equals("&")) {
            Main.warn("hex integer literals on line "
                               + t.beginLine + " not implemented");
            intVal = -1;
        } else {
            intVal = Integer.parseInt(t.image.substring(1));
        }
        return new Integer(intVal);
    }
}

/********************
 * ARM Instructions *
 ********************/
ARMInstruction Arithmetic():
{
    Token t;
    List<Object> args;
    ARMInstruction i;
}
{
    ( (t=<MOV>|t=<MVN>) args=RegCommaOperand1()
            |(t=<ADD>|t=<ADC>|t=<SUB>|t=<SBC>|t=<RSB>|t=<RSC>)
      args=RegCommaRegCommaOperand1()
      |t=<MUL> args=RegList2()
      |(t=<MLA>|t=<UMULL>|t=<UMLAL>|t=<SMULL>|t=<SMLAL>) args=RegList3()
      |t=<CLZ> args=RegList1()
      |t=<ADR> args=RegCommaId()
      |(t=<TST>|t=<TEQ>|t=<CMP>|t=<CMN>) args=RegCommaOperand1()
      |(t=<AND>|t=<EOR>|t=<ORR>|t=<BIC>) args=RegCommaRegCommaOperand1()) {
          boolean conditional = false;

          if (t.image.substring(0, 3).equals("mov")
              && t.image.length() > 4)
              conditional = true;
          i = new ARMInstruction(t.image, args, 1, conditional);
          i.setInput(input); i.setLine(t.beginLine);
          return i;
      }
      |t=<MRS> args=RegCommaPSR() {
           i = new ARMInstruction(t.image, args, 20, false);
           i.setInput(input); i.setLine(t.beginLine);
           return i;
      }
      |t=<MSR> args=PSRfieldsCommaRegORImm() {
        i = new ARMInstruction(t.image, args, 30, false);
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }

}

ARMInstruction Branch():
{
    Token t;
    String l;
    ARMRegister reg;
    List<Object> args;
    ARMInstruction i;
}
{
    (t=<B> l=Id()) {
        boolean conditional = true;

        if (t.image.equals("b")
            || t.image.equals("bal")
            || t.image.equals("bl")
            || t.image.equals("blal")) {
            conditional = false;
        }

        args = new ArrayList<Object>();
        i = new ARMInstruction(t.image, args, 4, conditional);
        i.setBranch(conditional);
        i.setBranchTarget(l/*targetLabel*/);
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
}

ARMInstruction BranchAndLink():
{
    Token t;
    String l;
    ARMRegister reg;
    List<Object> args;
    ARMInstruction i;
}
{
    (t=<BL> l=Id()) {
        args = new ArrayList<Object>();
        i = new ARMInstruction(t.image, args, 4, false);
        i.setBranch(false);
        i.setBranchTarget(l/*targetLabel*/);
        i.setCall(false);
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
    | (t=<BX> reg=Reg()) {
        Main.warn("BX instruction on line " + t.beginLine
                           + " not supported");
        return null;
    }
}

ARMInstruction Misc(): 
{
    Token t;
    List<Object> args;
    ARMInstruction i;
    Integer val;
}
{
    t=<LDM> args=MultipleRegs() {
        boolean conditional = true;

        if (t.image.equals("ldmea")
            || t.image.equals("ldmfa")
            || t.image.equals("ldmed")
            || t.image.equals("ldmfd")) {
            conditional = false;
        }
        /*
        if (args.contains(registers.r[ARMMachine.PC])) {
            boolean conditional = true;

            if (t.image.equals("ldmea")
                || t.image.equals("ldmfa")
                || t.image.equals("ldmed")
                || t.image.equals("ldmfd")) {
                conditional = false;
            }
            i = new Return(t.image,
                           args,
                           conditional);
                           } else {*/
        i = new ARMInstruction(t.image, args, 2, conditional);
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
    |(
      t=<SWI> val=Int() {
          args = new ArrayList<Object>();
          args.add(val);
      }
     |t=<SWP> args=SwapList()
     |t=<NOP> {
         args = new ArrayList<Object>();
     }
      ) {
        i = new ARMInstruction(t.image, args, 1, false); 
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
    |((t=<LDR>|t=<LDRB>|t=<LDRT>|t=<LDRBT>) args=RegCommaAddr2() 
      |(t=<LDRSB>|t=<LDRH>|t=<LDRSH>) args=RegCommaAddr3()) {
        i = new ARMInstruction(t.image, args, 1, false); // assume unconditional
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
    |t=<STM> args=MultipleRegs() {
        i = new ARMInstruction(t.image, args, 1, false); 
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
    |(t=<STR>|t=<STRB>|t=<STRT>|t=<STRBT>|t=<STRH>) args=RegCommaAddr2() {
        i = new ARMInstruction(t.image, args, 2, false);
        i.setInput(input); i.setLine(t.beginLine);
        return i;
    }
}

/************************
 * Helper non-terminals *
 ************************/
List<Object> SwapList():
{
    ARMRegister target, source1, source2;
    List<Object> args;
}
{
    target=Reg() <COMMA> source1=Reg() <COMMA>
        <LBRACKET> source2=Reg() <RBRACKET> {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(source2); 
        return args;
    }
}

List<Object> Regs():
{
    List<Object> l,l2;
    ARMRegister r,r2,s;
    int i;
}
{
    LOOKAHEAD(5) r=Reg() <MINUS> r2=Reg() <COMMA> l=Regs() {
        l2 = new ArrayList<Object>();
        i = r.getPos();
        while (i <= r2.getPos()) {
            l2.add(registers.r[i]);
            i++;
        }
        l2.addAll(l);
        return l2;
    }
    |LOOKAHEAD(3) r=Reg() <MINUS> r2=Reg() {
        l2 = new ArrayList<Object>();
        i = r.getPos();
        while (i <= r2.getPos()) {
            l2.add(registers.r[i]);
            i++;
        }
        return l2;
    }
    |LOOKAHEAD(2) r=Reg() <COMMA> l=Regs() {
        l2 = new ArrayList<Object>();
        l2.add(r);
        l2.addAll(l);
        return l2;
    }
    |r=Reg() {
        l = new ArrayList<Object>();
        l.add(r);
        return l;
    }
}

List<Object> RegList():
{
    List<Object> r;
}
{
    <LBRACE> r=Regs() <RBRACE> {
        return r;
    }
}

List<Object> Operand1():
{
    ArrayList<Object> list;
    Integer val;
    ARMRegister reg1, reg2;
    Token t1, t2;
    ShiftRegister sr;
    ShiftImmediate si;
}
{
    val=Int() {
        list = new ArrayList<Object>();
        list.add(val);
        return list;
    }
    |LOOKAHEAD(4) reg1=Reg() <COMMA> sr=ShiftReg() {
        list = new ArrayList<Object>();
        list.add(reg1);
        list.add(sr);
        return list; }
    |LOOKAHEAD(4) reg1=Reg() <COMMA> si=ShiftImm() {
        list = new ArrayList<Object>();
        list.add(reg1);
        list.add(si);
        return list; }
    |LOOKAHEAD(4) reg1=Reg() <COMMA> <RRX> {
        list = new ArrayList<Object>();
        list.add(reg1);
        list.add(new ShiftOperand(ShiftOperand.RRX));
        return list;
    }
    | reg1=Reg() {
        list = new ArrayList<Object>();
        list.add(reg1);
        return list;
    }
}

ShiftOperand ShiftOp():
{}
{
    (<LSL>
    { return new ShiftOperand(ShiftOperand.LSL); }
    |<LSR>
    { return new ShiftOperand(ShiftOperand.LSR); }
    |<ASL>
    { return new ShiftOperand(ShiftOperand.ASL); }
    |<ASR>
    { return new ShiftOperand(ShiftOperand.ASR); }
    |<ROR>
    { return new ShiftOperand(ShiftOperand.ROR); }
    |<RRX>
    { return new ShiftOperand(ShiftOperand.RRX); }
    )
}

ShiftImmediate ShiftImm():
{
    ShiftOperand so;
    Integer val;
}
{
    so=ShiftOp() val=Int() {
        return new ShiftImmediate(so, val.intValue());
    }
}

ShiftRegister ShiftReg():
{
    ShiftOperand so;
    ARMRegister reg;
}
{
    so=ShiftOp() reg=Reg() {
        return new ShiftRegister(so, reg);
    }
}

// zzz fix this (also in ARMInput.java:convertLabels())
String Sign():
{}
{
    <PLUS> {
        return "+";
    }
    | <MINUS> {
        return "-";
    }
    | {
        return null;
    }
}

// false=negative, true=positive
boolean Exclamation():
{}
{
    <EXCLAMATION> {
        return true;
    }
    | {
        return false;
    }
}

boolean Hat():
{}
{
    <HAT> {
        return true;
    }
    | {
        return false;
    }
}

List<Object> MultipleRegs():
{
    ARMRegister target;
    boolean exclamation;
    boolean hat;
    int specialargs;
    List<Object> args, tail;
}
{
    target=Reg() exclamation=Exclamation() <COMMA>
        tail=RegList() hat=Hat() /* [<HAT>] /* zzz hattu ja huutomerkki */ {
        args = new ArrayList<Object>();
        args.add(target);
        args.addAll(tail);
        specialargs = 0;
        if (exclamation) {
            specialargs = specialargs + 1;
        }
        if (hat) {
            specialargs = specialargs + 10;
        }
        args.add(new Integer(specialargs));
    
        return args;
    }
}

List<Object> RegCommaId():
{
    List<Object> args;
    ARMRegister target;
    //  String s;
}
{
    target=Reg() <COMMA> Expr() {
        args = new ArrayList<Object>();
        args.add(target);
        //      args.add(s); zzz
        return args;
    }
}

List<Object> RegCommaOperand1(): 
{
    List<Object> args, tail;
    ARMRegister target;
}
{
    target=Reg() <COMMA> tail=Operand1() {
        args = new ArrayList<Object>();
        args.add(target);
        if (tail != null)
            args.addAll(tail);
        return args;
    }
}

List<Object> RegCommaRegCommaOperand1():
{
    List<Object> args, tail;
    ARMRegister target, source;
}
{
    target=Reg() <COMMA> source=Reg() <COMMA> tail=Operand1() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source);
        if (tail != null)
            args.addAll(tail);
        return args;
    }
}

// this includes RegCommaAddr2Post, assuming gcc will produce valid assembler
List<Object> RegCommaAddr2():
{
    List<Object> args;
    /*
     * target, source1, sign, source2, val, shift, type
     * For "type" see ARM DDI 0100E page A5-18
     */
    Integer val;
    ARMRegister target, source1, source2;
    String sign;
    ShiftOperand so;
    ShiftImmediate si;
    boolean exclamation;
    Expression expr;
}
{
    { val = new Integer(0); }
    (  //LOOKAHEAD(5) target=Reg() <COMMA> Id() <PLUS> Num()
    
     LOOKAHEAD(3) target=Reg() <COMMA> expr=Expr() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(expr); // kps hack
         return args;
     } // zzz
     |LOOKAHEAD(7) target=Reg() <COMMA> <LBRACKET> source1=Reg() <COMMA>
     val=Int() <RBRACKET> exclamation=Exclamation() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(null);
         args.add(null);
         args.add(val);
         args.add(null);
         if (!exclamation) {
             args.add(new Integer(1));
         } else {
             args.add(new Integer(4));
         }
         return args;
     }
     |LOOKAHEAD(8) target=Reg() <COMMA> <LBRACKET> source1=Reg() <COMMA>
     sign=Sign() source2=Reg() <RBRACKET> exclamation=Exclamation() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(sign);
         args.add(source2);
         args.add(null);
         args.add(null);
         if (!exclamation) {
             args.add(new Integer(2));
         } else {
             args.add(new Integer(5));
         }
         return args;
     }
     |LOOKAHEAD(9) target=Reg() <COMMA> <LBRACKET> source1=Reg() <COMMA>
     sign=Sign() source2=Reg() <COMMA>
     si=ShiftImm() <RBRACKET> exclamation=Exclamation() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(sign);
         args.add(source2);
         args.add(si);
         if (!exclamation) {
             args.add(new Integer(3));
         } else {
             args.add(new Integer(6));
         }
         return args;
     }
     |LOOKAHEAD(7) target=Reg() <COMMA>
     <LBRACKET> source1=Reg() <RBRACKET> <COMMA> val=Int() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(null);
         args.add(null);
         args.add(val);
         args.add(null);
         args.add(new Integer(7));
         return args;
     }
     |LOOKAHEAD(10) target=Reg() <COMMA>
     <LBRACKET> source1=Reg() <RBRACKET> <COMMA>
     sign=Sign() source2=Reg() <COMMA> si=ShiftImm() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(sign);
         args.add(source2);
         args.add(si);
         args.add(new Integer(9));
         return args;
     }
     |LOOKAHEAD(7) target=Reg() <COMMA>
     <LBRACKET> source1=Reg() <RBRACKET> <COMMA> sign=Sign() source2=Reg() {
         args = new ArrayList<Object>();
         args.add(target);
         args.add(source1);
         args.add(sign);
         args.add(source2);
         args.add(null);
         args.add(null);
         args.add(new Integer(8));
         return args;
     }
     | target=Reg() <COMMA> Expr() {
         return null;
     })
}

List<Object> RegCommaAddr3():
{
    List<Object> args;
    /*
     * target, source1, sign, source2, val, shift, type
     * For "type" see ARM DDI 0100E page A5-34
     */
    Integer val;
    ARMRegister target, source1, source2;
    String sign;
    Token s;
    boolean exclamation;
}
{
    LOOKAHEAD(6) target=Reg() <COMMA> <LBRACKET> source1=Reg() <COMMA> 
        val=Int() <RBRACKET> exclamation=Exclamation() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(null);
        args.add(null);
        args.add(val);
        args.add(null);
        if (!exclamation) {
            args.add(new Integer(1));
        } else {
            args.add(new Integer(3));
        }
        return args;
    }
    |LOOKAHEAD(6) target=Reg() <COMMA> <LBRACKET> source1=Reg() <COMMA>
         sign=Sign() source2=Reg() <RBRACKET> exclamation=Exclamation() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(sign);
        args.add(source2);
        args.add(null);
        args.add(null);
        if (!exclamation) {
            args.add(new Integer(2));
        } else {
            args.add(new Integer(4));
        }
        return args;
    }
    |LOOKAHEAD(6) target=Reg() <COMMA>
         <LBRACKET> source1=Reg() <RBRACKET> <COMMA> val=Int() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(null);
        args.add(null);
        args.add(val);
        args.add(null);
        args.add(new Integer(5));
        return args;
    }
    |LOOKAHEAD(6) target=Reg() <COMMA>
         <LBRACKET> source1=Reg() <RBRACKET> sign=Sign() source2=Reg() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(sign);
        args.add(source2);
        args.add(null);
        args.add(null);
        args.add(new Integer(6));
        return args;
    }
}

List<Object> RegList1():
{
    List<Object> args, tail;
    ARMRegister target, source;
}
{
    target=Reg() <COMMA> source=Reg() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source);
        return args;
    }
}

List<Object> RegList2():
{
    List<Object> args, tail;
    ARMRegister target, source1, source2;
}
{
    target=Reg() <COMMA> source1=Reg() <COMMA> source2=Reg() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(source2);
        return args;
    }
}

List<Object> RegList3():
{
    List<Object> args, tail;
    ARMRegister target, source1, source2, source3;
}
{
    target=Reg() <COMMA> source1=Reg() <COMMA> source2=Reg() <COMMA>
        source3=Reg() {
        args = new ArrayList<Object>();
        args.add(target);
        args.add(source1);
        args.add(source2);
        args.add(source3);
        return args;
    }
}

List<Object> RegCommaPSR():
{
    Token t;
    List<Object> args;
    ARMRegister target;
}
{
    LOOKAHEAD(3) target=Reg() <COMMA> t=<CPSR> {
        args = new ArrayList<Object>();
        args.add(new PSRField(t.toString()));
        args.add(target);
        args.add(registers.r[ARMMachine.CPSR]);
        return args;
    } 
    | target=Reg() <COMMA> t=<SPSR> {
        args = new ArrayList<Object>();  
        args.add(new PSRField(t.toString()));
        args.add(target);
        args.add(registers.r[1]); // zzz 
        return args;
    }
}

List<Object> PSRfieldsCommaRegORImm():
{
    Token t;
    List<Object> args;
    ARMRegister target;
    Integer val;
}
{
    LOOKAHEAD(4) t=<CPSR> <COMMA> target=Reg() {
        args = new ArrayList<Object>();
        args.add(new PSRField(t.toString()));
        args.add(target);
        args.add(registers.r[ARMMachine.CPSR]);
        return args;
    } 
    | LOOKAHEAD(4) t=<SPSR> <COMMA> target=Reg() {
        args = new ArrayList<Object>();  
        args.add(new PSRField(t.toString()));
        args.add(target);
        args.add(registers.r[1]); // zzz 
        return args;
    }
    | LOOKAHEAD(4) t=<CPSR> <COMMA> val=Int() {
        args = new ArrayList<Object>();  
        args.add(new PSRField(t.toString()));
        args.add(val);
        args.add(registers.r[16]);
        return args;
    }
    | LOOKAHEAD(4) t=<SPSR>  <COMMA> val=Int() {
        args = new ArrayList<Object>();  
        args.add(new PSRField(t.toString()));
        args.add(val);
        args.add(registers.r[1]); // zzz 
        return args;
    }
}
