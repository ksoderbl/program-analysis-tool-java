// -*- java -*-
/**
 * Parser generator file for Texas Instruments C55x disassembly (from dis55 tool).
 *
 * @author Kristian SÃ¶derblom
 */
options {
    STATIC=false;
    //FORCE_LA_CHECK=true;
    COMMON_TOKEN_ACTION=true;
}

PARSER_BEGIN(C55xDisParser)

package c55x.dis;

import c55x.*;
import c55x.instr.*;
import input.Input;
import input.InputLineObject;
import instr.*;
import machine.Machine;
import program.Label;
import main.*;
import misc.*;
import pseudoOp.*;

import java.util.List;
import java.util.ArrayList;
import java.io.*;

class C55xDisParser
{
    private Input input;
    private List inputLines;
    private C55xMachine m;
    private String filename;
    private String myname;

    C55xDisParser(InputStream in, Input input, C55xMachine machine) {
        this(in);
        this.input = input;
        this.inputLines = input.getInputLines();
        this.filename = input.getFileName();
        this.m = machine;
        this.myname = "C55xDisParser: " + this.filename + ": ";
    }

    /**
     * @return value of a integer constant String as a long
     */
    static long parseNum(String num) {
        if (num.startsWith("0x"))
            return Long.parseLong(num.substring(2), 16);
        if (num.endsWith("h") || num.endsWith("H"))
            return Long.parseLong(num.substring(0,num.length()-1), 16);
        if (num.endsWith("q") || num.endsWith("Q"))
            return Long.parseLong(num.substring(0,num.length()-1), 8);
        if (num.endsWith("b") || num.endsWith("B"))
            return Long.parseLong(num.substring(0,num.length()-1), 2);
        if (num.startsWith("0"))
            return Long.parseLong(num, 8);
        return Long.parseLong(num);
    }
}

PARSER_END(C55xDisParser)

//
// Lexer: Tokens
//

// ALTUG  = Assembly Language Tool User's Guide      (spru280h)
// CPUREF = DSP CPU Reference Guide                  (spru371f>
// MISRG  = Mnemonic Instruction Set Reference Guide (spru374g)


TOKEN_MGR_DECLS :
{
    void CommonTokenAction(Token t) {

        // hack to make sure hexadecimal numbers at start of line in
        // outputlines like
        // 000000: 1a0104           OR #1,T0,AC0
        // are treated as HEXADECIMALINT_THREE type tokens
        if ((t.kind == NUM || t.kind == ID || t.kind == AADD)
            && t.beginColumn < 20) {
            t.kind = HEXHACK;
        }

        if ((t.kind == DISASSEMBLY
             || t.kind == DIS_TEXT
             || t.kind == DIS_DATA)
            && t.beginColumn != 1) {
            t.kind = ID;
        }

        //System.out.println("" + t.beginLine + ":" + t.beginColumn + ": kind of token '"+t+"' is " + t.kind );

        /*
        Token s = t.specialToken;
        while (s != null) {
            System.out.println("special = '" +s);
            s = s.specialToken;
        }
        */
    }

}



// White space

SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r"
}


// Source comments
//
// Note that before calling the lexer, some java code in C55xAsmInput.java
// changes comment lines starting with a '*' to lines starting with a ';'.
// This simplifies tokenizing the comments.
//
// For source comments, we define a lexical state IN_COMMENT.
// When we see a semicolon, the lexer enters this state. All characters
// following the semicolon on the line are eaten up, until we see that
// a new line begins.
MORE :
{
    ";"   : IN_COMMENT
}

// When a new line begins we swap back to the DEFAULT lexical state.
// We make a special token out of the comment.
// 
// Note: the EOF must not be "commented out". That is, the file must
// end with a newline even if the last thing in the file is a comment.
<IN_COMMENT>
SPECIAL_TOKEN:
{
    <COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

// When any other character is seen in the IN_COMMENT state,
// make it part of the special token.
<IN_COMMENT>
MORE:
{
    < ~[] >
}

// kps -TODO - hack to treat lines like ...
// Disassembly of unpacki.obj:
// TEXT Section .fftcode, 0xAC bytes at 0x0
// ... as comments
MORE :
{
    <DISASSEMBLY: "Disassembly"> : IN_COMMENT
}

TOKEN :
{
    <DIS_TEXT: "TEXT">
  | <DIS_DATA: "DATA">
}


// Registers of the C55x. CPUREF p, 2-2
// These names are reserved, see p. 24 of MISRG.
TOKEN [IGNORE_CASE]:
{
   <AC0: "ac0"> | <AC1: "ac1"> | <AC2: "ac2"> | <AC3: "ac3">

 | <AC0_L: "ac0" ("_")? "l" >
 | <AC1_L: "ac1" ("_")? "l" >
 | <AC2_L: "ac2" ("_")? "l" >
 | <AC3_L: "ac3" ("_")? "l" >
 | <AC0_H: "ac0" ("_")? "h" >
 | <AC1_H: "ac1" ("_")? "h" >
 | <AC2_H: "ac2" ("_")? "h" >
 | <AC3_H: "ac3" ("_")? "h" >
 | <AC0_G: "ac0" ("_")? "g" > // sprs076n
 | <AC1_G: "ac1" ("_")? "g" >
 | <AC2_G: "ac2" ("_")? "g" >
 | <AC3_G: "ac3" ("_")? "g" >

 | <AR0: "ar0"> | <AR1: "ar1"> | <AR2: "ar2"> | <AR3: "ar3">
 | <AR4: "ar4"> | <AR5: "ar5"> | <AR6: "ar6"> | <AR7: "ar7">


             | <DR0: "dr0"> | <DR1: "dr1"> // UNDOCUMENTED from example sources
             | <DR2: "dr2"> | <DR3: "dr3">
             // DR0 == T0, DR1 == T1


             /*| <AR0B: "ar0b">
 | <AR0H: "ar0h"> | <AR1H: "ar1h"> | <AR2H: "ar2h"> | <AR3H: "ar3h">
 | <AR4H: "ar4h"> | <AR5H: "ar5h"> | <AR6H: "ar6h"> | <AR7H: "ar7h">*/

 | <BK03: "bk03"> | <BK47: "bk47"> | <BKC: "bkc">
 | <BRC0: "brc0"> | <BRC1: "brc1"> | <BRS1: "brs1">

 | <BSA01: "bsa01"> | <BSA23: "bsa23">
 | <BSA45: "bsa45"> | <BSA67: "bsa67"> | <BSAC: "bsac">

 | <CDP: "cdp"> | <CDPH: "cdph">
 | <CFCT: "cfct"> | <CSR: "csr">
 | <DBIER0: "dbier0"> | <DBIER1: "dbier1">

 | <DP: "dp"> | <DPH: "dph">

             // kps - not needed | <DP_L: "dp" ("_")? "l" > // REG19_L() needed?// dis55 changes mmap(@DP_L) to mmap(@DP)

 | <IER0: "ier0"> | <IER1: "ier1">
 | <IFR0: "ifr0"> | <IFR1: "ifr1">
 | <IVPD: "ivpd"> | <IVPH: "ivph">

 | <PC: "pc"> | <PDP: "pdp">
 | <REA0: "rea0"> | <REA1: "rea1">
 | <RETA: "reta">

 | <RPTC: "rptc"> | <RSA0: "rsa0"> | <RSA1: "rsa1">
 | <SP: "sp"> | <SPH: "sph"> | <SSP: "ssp">

 // supporting _l in these is not useful here
 // disassembler doesn't produce such
 // | <T0: "t0" (("_")? "l")? > // t0 or t0_l
 // | <T1: "t1" (("_")? "l")? >
 // | <T2: "t2" (("_")? "l")? >
 // | <T3: "t3" (("_")? "l")? >
 | <ST0_55: "st0" ("_55")?> | <ST1_55: "st1" ("_55")?>
 | <ST2_55: "st2" ("_55")?> | <ST3_55: "st3" ("_55")?>

 | <T0: "t0"> | <T1: "t1"> | <T2: "t2"> | <T3: "t3">

 | <T0B: "t0b">

 | <TRN0: "trn0"> | <TRN1: "trn1">

 | <XAR0: "xar0"> | <XAR1: "xar1"> | <XAR2: "xar2"> | <XAR3: "xar3">
 | <XAR4: "xar4"> | <XAR5: "xar5"> | <XAR6: "xar6"> | <XAR7: "xar7">
 | <XCDP: "xcdp"> | <XDP: "xdp"> | <XSP: "xsp"> | <XSSP: "xssp">
}

// Names of status bits. CPUREF p. 5-18 - 5-21
// Let's assume these are also reserved.
TOKEN [IGNORE_CASE]:
{
    // status bits in register ST0_55
    /* dp? */ 
   <ACOV0  : ("st0_")? "acov0" >
 | <ACOV1  : ("st0_")? "acov1" >
 | <CARRY  : ("st0_")? "carry" >
 | <BORROW : ("st0_")? "borrow"> // not a separate bit?
 | <TC1    : ("st0_")? "tc1"   >
 | <TC2    : ("st0_")? "tc2"   >
 | <ACOV2  : ("st0_")? "acov2" >
 | <ACOV3  : ("st0_")? "acov3" >
 
 // ST1_55
 | <ASM    : ("st1_")? "asm"   >
 | <C54CM  : ("st1_")? "c54cm" >
 | <FRCT   : ("st1_")? "frct"  >
 | <C16    : ("st1_")? "c16"   >
 | <SXMD   : ("st1_")? "sxm" ("d")? >
 | <SATD   : ("st1_")? "satd"  >
 | <M40    : ("st1_")? "m40"   >
 | <INTM   : ("st1_")? "intm"  >
 | <HM     : ("st1_")? "hm"    >
 | <XF     : ("st1_")? "xf"    >
 | <CPL    : ("st1_")? "cpl"   >
 | <BRAF   : ("st1_")? "braf"  >

 // ST2_55
 | <AR0LC  : ("st2_")? "ar0lc"  >
 | <AR1LC  : ("st2_")? "ar1lc"  >
 | <AR2LC  : ("st2_")? "ar2lc"  >
 | <AR3LC  : ("st2_")? "ar3lc"  >
 | <AR4LC  : ("st2_")? "ar4lc"  >
 | <AR5LC  : ("st2_")? "ar5lc"  >
 | <AR6LC  : ("st2_")? "ar6lc"  >
 | <AR7LC  : ("st2_")? "ar7lc"  >
 | <CDPLC  : ("st2_")? "cdplc"  >
 | <RDM    : ("st2_")? "rdm"    >
 | <EALLOW : ("st2_")? "eallow" >
 | <DBGM   : ("st2_")? "dbgm"   >
 | <ARMS   : ("st2_")? "arms"   >

 // ST3_55
 | <SST    : ("st3_")? "sst"    >
 | <SMUL   : ("st3_")? "smul"   >
 | <CLKOFF : ("st3_")? "clkoff" >
 | <SATA   : ("st3_")? "sata"   >
 | <MPNMC  : ("st3_")? "mpnmc"  >

 | <CBERR  : ("st3_")? "cberr"  >
 | <HINT   : ("st3_")? "hint"   >
 | <CACLR  : ("st3_")? "caclr"  >
 | <CAEN   : ("st3_")? "caen"   >
 | <CAFRZ  : ("st3_")? "cafrz"  >
}


//
// Mnemonic instruction set reference quotes:
// 1.4.2.1 Reserved Words
//   Register names are reserved and they may not be used as names of identifi-
//   ers, labels, etc. Mnemonic syntax names are not reserved.
//

// MISRG p. 60:
// You can use the circular addressing instruction qualifier,
// .CR, if you want every pointer used by the instruction to be
// modified circularly, just add .CR to the end of the instruction
// mnemonic (for example, ADD.CR). The circular addressing
// instruction qualifier overrides the linear/circular configuration
// in ST2_55.

// If you add to the end or beginning of this list, change CommonTokenAction.

TOKEN [IGNORE_CASE]:
{
    < AADD: "aadd" >
  | < ABDST: "abdst" >
  | < ABS: "abs" >
  | < ADD: "add" <C> > // allow addc also, really needed only for p.119 instruction
  | < ADDSUB: "addsub" >
  | < ADDSUBCC: "addsubcc" >
  | < ADDSUB2CC: "addsub2cc" >
  | < ADDV: "add" <R> "v" >
  | < AMAR: "amar" >
  | < AMOV: "amov" >
  | < AND: "and" >
  | < ASUB: "asub" >
  | < B: "b" >
  | < BAND: "band" >
  | < BCC: "bcc" <U> >
  | < BCLR: "bclr" >
  | < BCNT: "bcnt" >
  | < BFXPA: "bfxpa" >
  | < BFXTR: "bfxtr" >
  | < BNOT: "bnot" >
  | < BSET: "bset" >
  | < BTST: "btst" >
  | < BTSTCLR: "btstclr" >
  | < BTSTNOT: "btstnot" >
  | < BTSTP: "btstp" >
  | < BTSTSET: "btstset" >
  | < CALL: "call" >
  | < CALLCC: ("callcc"|"calcc") > // calcc is a dis55 bug?
  | < CMP: "cmp" >
  | < CMPU: "cmpu" >
  | < CMPAND: "cmpand" <U> >
  | < CMPOR: "cmpor" <U> >
  | < DELAY: "delay" >
  | < EXP: "exp" >
  | < FIRSADD: "firsadd" >
  | < FIRSSUB: "firssub" >
  | < IDLE: "idle" >
  | < INTR: "intr" >
  | < LMS: "lms" >

  | < MAC:   "mac" <R> <FORTY> >      // "mac" or "macr"
  | < MAS:   "mas" <R> <FORTY> >      // "mas" or "masr"
  | < MPY:   "mpy" <R> <FORTY> >      // "mpy" or "mpyr"
  | < MPYK: "mpyk" <R> >
  | < MACK: "mack" <R> >
  | < MACM: "macm" <R> <FORTY> >
  | < MACMK: "macmk" <R> >
  | < MASM: "masm" <R> <FORTY> >
  | < MPYM: "mpym" <R> (<U>|<FORTY>) >
  | < MPYMK: "mpymk" <R> >
  | < MACMZ: "macm" <R> "z" >

  | < MANT: "mant" >
                //  | < MAR: "mar" > // kps - documented where?
  | < MAX: "max" >
  | < MAXDIFF: "maxdiff" >
  | < DMAXDIFF: "dmaxdiff" >
  | < MIN: "min" >
  | < MINDIFF: "mindiff" >
  | < DMINDIFF: "dmindiff" >
  | < MMAP: "mmap"> // MISRG p. 76

  | < MOV: "mov" >
  | < MOV40: "mov4" ("0")? > // mov40 can appear as mov4 in dissambly

  | < NEG: "neg" >
  | < NEXP: "nexp" >
  | < NOP: "nop" >
  | < NOP_16: "nop_16" >
  | < NOT: "not" >
  | < OR: "or"  >
  | < POP: "pop" >
  | < POPBOTH: "popboth" >
  | < PSH: "psh" >
  | < PSHBOTH: "pshboth" >
  | < RESET: "reset" >
  | < RET: "ret" >
  | < RETCC: "retcc" >
  | < RETI: "reti" >
  | < ROL: "rol" >
  | < ROR: "ror" >
  | < ROUND: "round" >
  | < RPT: "rpt" >
  | < RPTADD: "rptadd" >
  | < RPTB: "rptb" >
  | < RPTBLOCAL: "rptblocal" >
  | < RPTCC: "rptcc" >
  | < RPTSUB: "rptsub" >
  | < SAT: "sat" <R> >
  | < SFTCC: "sftcc" > 
  | < SFTL: "sftl" > 
  | < SFTS: "sfts" >
                //| < SFTA: "sfta" > // sfta is really a c54x instruction (sfts == sfta)
  | < SFTSC: "sftsc" > 
  | < SIM_TRIG: "sim_trig" > // from viterbi.dis

  | < SQA: "sqa" <R> >
  | < SQAM: "sqam" <R> >
  | < SQDST: "sqdst"<R> >
  | < SQR: "sqr" <R> >
  | < SQRM: "sqrm" <R> >
  | < SQS: "sqs" <R> >
  | < SQSM: "sqsm" <R> >

  | < SUB: "sub" >
  | < SUBB: "subb" >
  | < SUBADD: "subadd" >
  | < SUBC: "subc" >
  | < SWAP: "swap" >
  | < SWAPP: "swapp" >
  | < SWAP4: "swap4" >
  | < TRAP: "trap" >
  | < XCC: "xcc" >
  | < XCCPART: "xccpart" >
  | < XOR: "xor" >

  | < #C: ("c")? >
  | < #U: ("u")? >
  | < #R: ("r")? >
  | < #FORTY: ("4" ("0")?)? > // 40, 4 or nothing
  | < #CRLR: (".lr"|".cr")? > // kps - todo - add this CRLR to all of the relevant instruction tokens? p.241

}

//
// Operand modifiers
// ALTUG p. 30
//
// If you add to the end or beginning of this list, change CommonTokenAction.
//
TOKEN [IGNORE_CASE]:
{
   <ABS16: "abs16">
 | <BLOCK: "block">
 | <DBL: "dbl">
 | <DUAL: "dual">
 | <HI: "hi">
 | <HIGH_BYTE: "high_byte">
 | <LO: "lo">
 | <LOW_BYTE: "low_byte">
 | <MMR: "mmr"> // MISRG p. 29
 | <OVERFLOW: "overflow"> // kps - documented where?
 | <PAIR: "pair">
 | <PORT: "port"> // MISRG p. 85
 | <RND: "rnd">
 | <SATURATE: "saturate">
 | <SHORTQ: "short">
 | <UNS: "uns"> // If the optional U or uns keyword is applied
                // to the input operand, the operand is zero extended

}

// Symbol. ALTUG p. 78

TOKEN:
{
    < ID: ["a"-"z","A"-"Z","$","_"] (["a"-"z","A"-"Z","0"-"9","$","_"])* >
}

// Quoted string. kps - OK ?
TOKEN:
{
    < QUOTED_STRING: "\"" (~["\""])* "\"" >
}

// Constant. ALTUG p. 74
// kps - TODO - add support for character and floating point constants
// and character strings?
TOKEN:
{
    < NUM:
      <BINARYINT>|<OCTALINT_ONE>|<OCTALINT_TWO>|<DECIMALINT>
           |<HEXADECIMALINT_ONE>|<HEXADECIMALINT_TWO> >

  | < #BINARYINT : ("0"|"1")+ ("b"|"B") >
  | < #OCTALINT_ONE : (["0"-"7"])+ ("q"|"Q") >
  | < #OCTALINT_TWO : "0" (["0"-"7"])* >
  | < #DECIMALINT : ["1"-"9"] (["0"-"9"])* >
  | < #HEXADECIMALINT_ONE : (["0"-"9","a"-"f","A"-"F"])+ ("h"|"H") >
  | < #HEXADECIMALINT_TWO : "0x" (["0"-"9","a"-"f","A"-"F"])+ >
           // used for the addresses and instruction words in the disassembly
           | < HEXHACK : (["0"-"9","a"-"f"])+ >
}

// Separators
TOKEN:
{
    < LPAREN: "(" >
                  | < RPAREN: ")" >
                  | < AT: "@" >
                  | < COLON: ":" >
                  | < COMMA: "," >
                  | < HASH: "#" >
                  | < UNDERSCORE: "_" >
                  | < DOT: "."  >  // used for section names: e.g. <DOT> Id()
}

// Instruction parallelism MISRG p.24, 35
TOKEN:
{
    < DOUBLE_COLONS: "::" >
                    | < PARALLEL_BARS: "||" >
}

// Operators
// MISRG p.16, ALTUG p.85
TOKEN:
{
    < PLUS: "+" > | < MINUS: "-" > | < TILDE: "~" > | < BANG: "!" >
  | < STAR: "*" > | < SLASH: "/" > | < PERCENT: "%" >
  //  add, sub
  | < LSHIFT: "<<" > | < RSHIFT: ">>" > // signed left/right shift
  | < LT: "<" >        | < LE: "<=" > | < GT: ">" > | < GE: ">=" >
                | < NE: "!=" > | < EQ: "==" > | < EQ1: "=" >
  | < BIT_AND: "&" >
  | < BIT_XOR: "^" >
  | < BIT_OR: "|" >
}


//
// Parser: Grammar
//

InputLineObject SourceLine() :
{
    Label l = null;
    PseudoOp pop;
    Object next, node;
    String s, id = null;
    Expression expr;
    Token t = null;
    C55xOperation oper0 = null, oper1 = null, oper2 = null, oper3 = null;
    String saddr, op, op2 = null, name, sizestr, datatype, st;
    long num, addr, value;
}
{
    // kps - useful for scratchpad?:
    // altug p.44
    // For an example that illustrates how to move a block of
    // code at runtime, see Example 8-7 on page 8-51.


    LOOKAHEAD(7)
    saddr = Hexhack() <COLON> <DOT> name=Id() <COLON> id=Id() <COLON> {
        // COFF sections, ALTUG p.30
        // e.g.
        // TEXT Section .text:cbrev, 0xDE bytes at 0x0
        // 000000:                _cbrev:
        // 000000:               .text:cbrev:  <- this line
        // DATA Section .data:twiddle32, 0x1000 words at 0x0
        // 000000:               twiddle32:
        // 000000:               .data:twiddle32: <- or this
        l = new Label("." + name + ":" + id, input); // kps -hack
        l.setInput(input);
        l.setAddr(saddr);
        return l;
    }
    | LOOKAHEAD(4)
    saddr = Hexhack() <COLON> <DOT> id=Id() <COLON> {
        // e.g. : 
        // DATA Section .cinit, 0x4 words at 0x0
        // 000000:               .cinit:
        // kps - not sure if making a label of these is clever
        l = new Label("." + id, input); // kps -hack
        l.setInput(input);
        l.setAddr(saddr);
        return l;
    }

    // e.g. 000026: 14c0a1_15c099    AMOV AR4,AR2 || AMOV AR4,AR1
    | LOOKAHEAD(  Hexhack() <COLON>      Hexhack()       (Hexhack())?         Oper() (<PARALLEL_BARS>         Oper())?)
          saddr = Hexhack() <COLON> op = Hexhack() (op2 = Hexhack())? oper0 = Oper() (<PARALLEL_BARS> oper2 = Oper())? {

              if (op2 != null) {
                  op = "" + op + op2;
              }

              C55xInstruction instr = new C55xInstruction();

              // Integer division by 2 rounds down, an extra '_' in
              // e.g. "b506_98" gives the correct size, 3 bytes.
              int size = op.length() / 2;
              instr.setMachineCode(op, size);
              instr.setAddr(saddr);
              instr.setInput(input);

              oper1 = oper0.getImplicitlyParallelOperation();
              if (oper2 != null) {
                  oper3 = oper2.getImplicitlyParallelOperation();
              }

              // some of these may be null
              instr.addOperation(oper0);
              instr.addOperation(oper1);
              instr.addOperation(oper2);
              instr.addOperation(oper3);

              return instr;
          }

    | LOOKAHEAD(Hexhack() <COLON> (<DOT>(Hexhack()|Id())<COLON>)? Label() <COLON>)
    saddr = Hexhack() <COLON> (<DOT>(id=Hexhack()|id=Id())<COLON>)? l = Label() <COLON> {
        // 000000:               _cbrev:
        // 000000:               .text:cbrev:
        // kps - TODO: handle the id
        l.setInput(input);
        l.setAddr(saddr);
        return l;
    }

    | saddr = Hexhack() <COLON> op = Hexhack() <DOT> datatype=Id() Num() {
        // e.g. 000003: ffff             .word 0xffff
        return new C55xDisDataPseudoOp(saddr, op, "." + datatype);
    }

    | st = SectionType() Hexhack() <DOT> name = Hexhack() (<COLON>(id=Hexhack()|id=Id()))? <COMMA> num=Num() sizestr=Id() Id() addr=Num() {
        // TEXT Section .text, 0x94 bytes at 0x0
        // DATA Section .data:twiddle32, 0x1000 words at 0x0
        return new C55xDisSectionPseudoOp(st, "." + name, id, num, sizestr, addr);
    }

}

void ParseInput() :
{
    InputLineObject next;
}
{
    {
        Main.info("C55xDisParser: Parsing file " + filename + ".");
    }

    // assembler source file consists of source lines
    (next=SourceLine()
        {
            //System.out.println("Got source line " + (String)next);
            inputLines.add(next);
        }
     )*
        <EOF>

    {
        Main.info("C55xDisParser: Parsed  file " + filename + ": SUCCESS.");
    }
}

String SectionType() :
{
    Token t;
}
{
    (t=<DIS_TEXT>|t=<DIS_DATA>) { return t.image; }
}

//
// Symbols from table 1-1 in MISRG.
// Register names, MISRG p. 24:
// "Register names are reserved and they may not be used as names of
// identifiers, labels, etc."
//

C55xRegisterOperand ACx() : // Accumulator, MISRG p. 12
{
    Token t;
}
{
    (t=<AC0>|t=<AC1>|t=<AC2>|t=<AC3>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand ACx_L() :
{
    Token t;
}
{
    (t=<AC0_L>|t=<AC1_L>|t=<AC2_L>|t=<AC3_L>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand ACx_H() :
{
    Token t;
}
{
    (t=<AC0_H>|t=<AC1_H>|t=<AC2_H>|t=<AC3_H>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand ACx_G() :
{
    Token t;
}
{
    (t=<AC0_G>|t=<AC1_G>|t=<AC2_G>|t=<AC3_G>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand ACy() : // Accumulator
{
    C55xRegisterOperand r;
}
{
    r = ACx() { return r; }
}

C55xRegisterOperand ARx() : // Auxiliary register, MISRG p. 12
{
    Token t;
}
{
    (t=<AR0>|t=<AR1>|t=<AR2>|t=<AR3>|t=<AR4>|t=<AR5>|t=<AR6>|t=<AR7>) {
        return new C55xRegisterOperand(t.image);
    }
}

// kps - on p. 28 (1-18) of MISRG we have this comment about Smem:
// "Syntax of Smem is the same as that of Lmem or Baddr",
// however, table 3-1, p. 42 says:
// "When an instruction contains Baddr, that instruction can access one
//  or two bits in an accumulator (AC0-AC3), an auxiliary register (AR0-AR7),
//  or a temporary register (T0-T3). Only the register bit test/set/
//  clear/complement instructions support Baddr."

C55xBaddrOperand Baddr() : // Register bit address, MISRG p. 42
{
    C55xRegisterOperand r = null;
    C55xMemoryAccessOperand ma = null;
    C55xBaddrOperand b = null;

}
{
    // kps todo - can be also e.g. *AR1(T0), e.g. in BTSTP *AR1(T0), AC0
    (r = ACx()|r = ARx()|r = Tx()|ma = Smem()) {
        if (r != null) {
            b = new C55xBaddrOperand(r);
        }
        if (ma != null) {
            b = new C55xBaddrOperand(ma);
        }
        return b;
    }
}

// BitIn  Shifted bit in: Test control flag 2 (TC2) or CARRY status bit
C55xBitOperand BitIn() : 
{
    Token t;
}
{
    (t=<TC2>|t=<CARRY>) {
        return new C55xBitOperand(t.image);
    }
}
// BitOut Shifted bit out: Test control flag 2 (TC2) or CARRY status bit
C55xBitOperand BitOut() :
{
    C55xBitOperand b;
}
{
    b = BitIn() { return b; }
}

String BITOP() :
{
    Token t;
}
{
    (t=<BIT_AND>|t=<BIT_OR>|t=<BIT_XOR>) {
        return t.image;
    }
}

// Condition based on accumulator (ACx) value, auxiliary register (ARx)
// value, temporary register (Tx) value, test control (TCx) flag, or
// CARRY status bit. See section 1.2.
// Conditional field (cond) on source accumulator, auxiliary, or temporary
// register; TCx; and CARRY: p.630

String OPTNot() :
{
    Token t = null;
}
{
    (t=<BANG>)? {
        if (t != null) {
            return t.image;
        }
        else {
            return "";
        }
    }
}

C55xConditionFieldOperand cond() : // condition field, MISRG p. 17
{
    List list = new ArrayList();
    Token hash = null;
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
    C55xBitOperand b = null, tc1, tc2;
    long num;
    String op, not, not2;
    
}
{
    r=src() op=RELOP() imm=Literal() /* "0" */ {
        // BCC #0x000125,AC0 >= #12
        // e.g. T0 != #0
        return new C55xConditionFieldOperand(op, r, imm);
    }
    | LOOKAHEAD(5)
          not=OPTNot() <OVERFLOW> <LPAREN> r=ACx() <RPAREN> {
        // e.g. !overflow(AC0)
        return new C55xConditionFieldOperand(not, r);
    }
    | LOOKAHEAD(2)
          not=OPTNot() (b=TCx()|b=CARRY()) {
        // e.g. !TC1
        return new C55xConditionFieldOperand(not, b);
    }
    | not=OPTNot() tc1=TC1() op=BITOP() not2=OPTNot() tc2=TC2() {
        // e.g. !TC1 & TC2
        return new C55xConditionFieldOperand(not, tc1, op, not2, tc2);
    }
}

// MISRG p.27 Rule 1
C55xImmediateOperand Literal() :
{
    Expression expr;
}
{
    // should be:
    // <HASH> (Num() | Id() | <RPAREN> Expr() <LPAREN>)
    // but is:
    <HASH> expr = Expr() {
        return new C55xImmediateOperand(expr.evaluate(null));
    }
         // EVIL HACK if no HASH
         // this matches also e.g. #-(blah + blah2) etc.
}

C55xImmediateOperand Literal16() :
{
    long num = -1;
}
{
    num = Num() {
        if (num != 16) {
            Main.fatal("Literal16 must be == 16");
        }
        return new C55xImmediateOperand(num, false); // don't emit #
    }
}

// MISRG p.27 Rule 2
/* unused
List DMAAddress() :
{
    List list = new ArrayList();
    Expression expr;
}
{
    <AT> (<HASH>) ? expr = Expr() { list.add(expr); return list; }
}
*/

// ALTUG p.72 ?

//The assembler allows you to specify that a constant, symbol, or
//expression should be used as an address, an immediate value, or an
//indirect value.
/* unused
List Address() :
{
    List list = new ArrayList();
}
{
    (<HASH> Expr()
         | Id()
     | <STAR> <RPAREN> (<HASH> Expr() | Id()) <LPAREN>)  { return list; }
}
*/

// Dx Data address label coded on x bits (absolute address)
C55xImmediateOperand D16() : { C55xImmediateOperand imm;} { imm = Literal() { return imm; }}

// 8-bit and 16-bit literals are allowed to be linktime-relocatable;
// for other literals, the value must be known at assembly time.

// kx Unsigned constant coded on x bits
C55xImmediateOperand k3()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k4()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k5()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k7()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k8()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k9()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k12() : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k16() : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k23() : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }

C55xImmediateOperand k4K16()     : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k4_k4K16()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand k8k16()     : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }

// Kx Signed constant coded on x bits, set type of imm to K8 or whatever ?
C55xImmediateOperand K8()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
C55xImmediateOperand K16() : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }
// K8 or K16
C55xImmediateOperand K8K16()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }

// hash '#' Ã­s optional in assembly, but seems to be there always in disassambly
C55xImmediateOperand OPTHASH_K16()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } } // MISRG p. 43
C55xImmediateOperand OPTHASH_k16()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } } // MISRG p. 43
C55xImmediateOperand OPTHASH_k23()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } } // MISRG p. 43, CPUREF p. 6-5




List<Operand> k4_k4K16_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k4_k4K16() <COMMA> r=dst() {
        list.add(imm);
        list.add(r);
        return list;
    }
}


// lx Program address label coded on x bits
// (unsigned offset relative to program counter register)
//List l4() :{}{}

// Lx Program address label coded on x bits
// (signed offset relative to program counter register)
//List L7() :
//{ List list = new ArrayList(); }
//{
//    (<HASH>)? Expr() { return list; /* kps todo */ }
//}

C55xImmediateOperand L8() :
{
    C55xImmediateOperand imm;
}
{
    imm = Literal() { // kps <HASH> used to be optional here
        // set imm type to L8 ?
        return imm;
    }
}

C55xImmediateOperand L16() :
{
    C55xImmediateOperand imm;
}
{
    imm = Literal() { // kps <HASH> used to be optional here
        // set imm type to L16 ?
        return imm;
    }
}

// Px Program or data address label coded on x bits (absolute address)
// OLD: 
//List P8() : {    List list = new ArrayList();    Expression expr; } {
//    (<HASH>)? expr = Expr() { list.add(expr); return list; }
//}
C55xImmediateOperand P8()  : { C55xImmediateOperand imm; } { imm = Literal() { return imm; } }

List Address_cond() :
{
    List list = new ArrayList();
    C55xConditionFieldOperand c;
    C55xProgramAddressOperand addr;
}
{
    addr = Address() <COMMA> c = cond() {
        list.add(addr);
        list.add(c);
        return list;
    }
}

// old name: L7L16P24
C55xProgramAddressOperand Address() :
{
    List list = new ArrayList();
    long addr = -1, num;
    String id = null;
    Token t = null;
}
{
    (t=<HASH>)? addr = Num() {
        if (t == null) {
            return new C55xProgramAddressOperand(addr, false);
        }
        else {
            return new C55xProgramAddressOperand(addr, true);
        }
    }
    | LOOKAHEAD(Id() <MINUS> Num())
          id = Id() <MINUS> num = Num() {
        return new C55xProgramAddressOperand(id, -num);
    }
    | id = Id() {
        return new C55xProgramAddressOperand(id);
    }
}

List<Operand> L16_ARn_mod_NE_0() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xProgramAddressOperand addr;
    C55xImmediateOperand zero; // zero must be #0
    C55xMemoryAccessOperand ma;
    C55xConditionFieldOperand cf;
}
{
    addr=Address() <COMMA> ma=ARn_mod() <NE> zero=Literal() {
        list.add(addr);
        if (zero.getValue() != 0) {
            Main.fatal("C55xDisParser: value should be 0 in L16_ARn_mod_NE_0");
        }
        cf = new C55xConditionFieldOperand(ma);
        list.add(cf);
        return list;
    }
}

C55xRegisterOperand CDP() :
{
    Token t;
}
{
    t=<CDP> {
        return new C55xRegisterOperand(t.image);
    }
}

// Coefficient indirect operand referencing
// a 16-bit or 32-bit value in data space
C55xMemoryAccessOperand Cmem() : // Coefficient operand, MISRG p. 12, 28 ... CDP something
{
    C55xRegisterOperand cdp, r2;
}
{
    LOOKAHEAD(3)   <STAR> cdp=CDP() <PLUS> {
        return new C55xMemoryAccessOperand("Cmem", C55xMemoryAccessOperand.POSTINC, cdp);
    }
    |LOOKAHEAD(3)  <STAR> cdp=CDP() <MINUS> {
        return new C55xMemoryAccessOperand("Cmem", C55xMemoryAccessOperand.POSTDEC, cdp);
    }
    |LOOKAHEAD(6)  <STAR> <LPAREN> cdp=CDP() <PLUS> (r2=T0()|r2=AR0()) <RPAREN> {
        return new C55xMemoryAccessOperand("Cmem", C55xMemoryAccessOperand.PLUSREGOFFSET, cdp, r2);
    }
    | <STAR> cdp=CDP() {
        return new C55xMemoryAccessOperand("Cmem", C55xMemoryAccessOperand.NOTMOD, cdp);        
    }
}

// Long-word single data memory access (32-bit data access).
// Same legal inputs as Smem.

C55xMemoryAccessOperand Lmem() : // long-word single data mem access (32 bit), MISRG p. 13
{
    C55xMemoryAccessOperand ma;
}
{
    ma = Smem2() {
        ma.setMode("Lmem");
        return ma;
    }
}

// possible memory mapped registers
C55xRegisterOperand MMReg() :
{
    C55xRegisterOperand r;
}
{
    (r=ACx_L()|r=ACx_H()|r=ACx_G()|r=STx()|r=Tx()|r=ARx()|r=REG19()) {
        return r;
    }
}

// Smem, with possible port() qualifier
C55xMemoryAccessOperand Smem() :
{
    C55xMemoryAccessOperand ma = null;
}
{
    LOOKAHEAD(<PORT> <LPAREN> Smem2() <RPAREN>)
    <PORT> <LPAREN> ma=Smem2() <RPAREN> {
        ma.setPortMod();
        return ma;
    }
    | ma=Smem2() {
        return ma;
    }
}

// MISRG p. 41: Introduction to addressing modes
// MISRG p. 629: AAAA AAAI
C55xMemoryAccessOperand Smem2() : // single data mem access (16 bit), MISRG p. 14
{
    C55xMemoryAccessOperand ma = new C55xMemoryAccessOperand("Smem");
    C55xRegisterOperand cdp, arx, r;
    C55xImmediateOperand imm;
}
{
    // examples:
    // mmap(ST1_55)
    // *SP(#(4+FRAME_SZ))

    LOOKAHEAD(<MMAP> <LPAREN> <AT> r=MMReg() <RPAREN>)
    <MMAP> <LPAREN> <AT> r=MMReg() <RPAREN> {
        return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.MMREG, r);
    }

    //|<MMAP> <LPAREN> MMReg() <RPAREN> {
    //        Main.fatal("BUU 1b");
    //        return ma;
    //}  // AT => dma?

    |LOOKAHEAD( <PORT> <LPAREN> Literal() <RPAREN>)
         <PORT> <LPAREN> imm=Literal() <RPAREN> {
        return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PORT16, imm);
    }

    |LOOKAHEAD(<STAR> <ABS16> <LPAREN> OPTHASH_k16() <RPAREN>)
         <STAR> <ABS16> <LPAREN> imm=OPTHASH_k16() <RPAREN> {
        return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.ABS16, imm);
    }

    |LOOKAHEAD(<STAR><LPAREN> OPTHASH_k23() <RPAREN>)
         <STAR><LPAREN> imm=OPTHASH_k23() <RPAREN> {
        return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.INDIRECT, imm);
    }

    |LOOKAHEAD(<STAR> CDP() <PLUS>)
         <STAR> cdp=CDP() <PLUS> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.POSTINC, cdp);
    }

    |LOOKAHEAD(<STAR> CDP() <MINUS>)
         <STAR> cdp=CDP() <MINUS> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.POSTDEC, cdp);
    }

    |LOOKAHEAD(<STAR> CDP() <LPAREN> OPTHASH_K16() <RPAREN>)
         <STAR> cdp=CDP() <LPAREN> OPTHASH_K16() <RPAREN> {
        Main.fatal("BUU 4c");
        return ma;
    }

    |LOOKAHEAD(<STAR> CDP())
         <STAR> cdp=CDP() {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.NOTMOD, cdp);        
    }
                   
    |LOOKAHEAD(<STAR> <PLUS> CDP() <LPAREN> OPTHASH_K16() <RPAREN>)
         <STAR> <PLUS> cdp=CDP() <LPAREN> imm=OPTHASH_K16() <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PREINC_IMMOFFSET, cdp, imm);
    }

    |LOOKAHEAD(<STAR> ARx() <LPAREN> <SHORTQ> <LPAREN> <HASH> Num() <RPAREN> <RPAREN>)
         <STAR> arx=ARx() <LPAREN> <SHORTQ> <LPAREN> <HASH> Num() <RPAREN> <RPAREN> {
        Main.fatal("BUU 6");
        return ma;
    }
                   
    |LOOKAHEAD(<STAR> <LPAREN> ARx() <PLUS> (T0()|T1()|T0B()) <RPAREN>) // *(AR0+T1)
         <STAR> <LPAREN> arx=ARx() <PLUS> (r=T0()|r=T1()|r=T0B()) <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PLUSREGOFFSET, arx, r);
    }

    |LOOKAHEAD(<STAR> <LPAREN> ARx() <MINUS> (T0()|T1()|T0B()) <RPAREN>)
         <STAR> <LPAREN> arx=ARx() <MINUS> (r=T0()|r=T1()|r=T0B()) <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.MINUSREGOFFSET, arx, r);
    }

    |LOOKAHEAD(<STAR> ARx() <LPAREN> (T0()|T1()) <RPAREN>)
         <STAR> arx=ARx() <LPAREN> (r=T0()|r=T1()) <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.REGOFFSET, arx, r);
        return ma;
    }

    |LOOKAHEAD(<STAR> ARx() <LPAREN> OPTHASH_K16() <RPAREN>) // *AR6(#0092h)
         <STAR> arx=ARx() <LPAREN> imm=OPTHASH_K16() <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.IMMOFFSET, arx, imm);
    }
                   
    |LOOKAHEAD(<STAR> ARx() <PLUS>)  // *ARn+
         <STAR> arx=ARx() <PLUS> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.POSTINC, arx);        
    }

    |LOOKAHEAD(<STAR> ARx() <MINUS>) // *ARn-
         <STAR> arx=ARx() <MINUS> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.POSTDEC, arx);        
    }

    |LOOKAHEAD(<STAR> ARx())  // *ARn 
         <STAR> arx=ARx() {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.NOTMOD, arx);        
    }
                   
    |LOOKAHEAD(<STAR> <PLUS> ARx() <LPAREN> OPTHASH_K16() <RPAREN>)
         <STAR> <PLUS> arx=ARx() <LPAREN> imm=OPTHASH_K16() <RPAREN> {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PREINC_IMMOFFSET, arx, imm);
    }
                   
    |LOOKAHEAD(<STAR> <PLUS> ARx()) 
         <STAR> <PLUS> arx=ARx() {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PREINC, arx);        
    }

    |LOOKAHEAD(<STAR> <MINUS> ARx()) 
         <STAR> <MINUS> arx=ARx() {
             return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.PREDEC, arx);        
    }
         
    |LOOKAHEAD(<STAR> <SP> <LPAREN> (<HASH>)? Expr() <RPAREN>)
         <STAR> <SP> <LPAREN> (<HASH>)? Expr() <RPAREN> {
        Main.fatal("BUU 12");
        return ma;
    }
    
    |<STAR> <LPAREN> (ACx_H()|ACx_L()) <RPAREN> {
        Main.fatal("BUU 13");
        return ma;
    }
    | LOOKAHEAD(<AT> Literal())
          <AT> imm=Literal() {
        return new C55xMemoryAccessOperand("Smem", C55xMemoryAccessOperand.DMA, imm);
    }
    | <AT> MMReg() {
        Main.fatal("BUU 15");
        return ma;
    }
}

 // Xmem, Ymem: **indirect** dual data mem access (two mem accesses), MISRG p. 15
// Smem, with possible port() qualifier
C55xMemoryAccessOperand Xmem() :
{
    C55xMemoryAccessOperand ma = null;
}
{
    LOOKAHEAD(<PORT> <LPAREN> Xmem2() <RPAREN>)
    <PORT> <LPAREN> ma=Xmem2() <RPAREN> {
        ma.setPortMod();
        return ma;
    }
    | ma=Xmem2() {
        return ma;
    }
}

C55xMemoryAccessOperand Xmem2() :
{
    C55xMemoryAccessOperand ma;
}
{
    ma = Ymem() { // Syntax of Xmem is the same as that of Ymem. MISRG. p.28
        ma.setMode("Xmem");
        return ma;
    }
}

C55xMemoryAccessOperand Ymem() :
{
    C55xMemoryAccessOperand ma = null;
}
{
    LOOKAHEAD(<PORT> <LPAREN> Ymem2() <RPAREN>)
    <PORT> <LPAREN> ma=Ymem2() <RPAREN> {
        ma.setPortMod();
        return ma;
    }
    | ma=Ymem2() {
        return ma;
    }
}

C55xMemoryAccessOperand Ymem2() : // single data mem access (16 bit), MISRG p. 14
{
    C55xRegisterOperand arx, r;
}
{
    LOOKAHEAD(3)   <STAR> arx=ARx() <PLUS> {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.POSTINC, arx);
    }
    |LOOKAHEAD(3)  <STAR> arx=ARx() <MINUS> {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.POSTDEC, arx);
    }
    |LOOKAHEAD(6)  <STAR> <LPAREN> arx=ARx() <PLUS>  (r=T0()|r=AR0()|r=T1()) <RPAREN> {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.PLUSREGOFFSET, arx, r);
    }
    |LOOKAHEAD(6)  <STAR> <LPAREN> arx=ARx() <MINUS> (r=T0()|r=AR0()|r=T1()) <RPAREN> {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.MINUSREGOFFSET, arx, r);
    }
    |LOOKAHEAD(5)  <STAR> arx=ARx() <LPAREN> (r=T0()|r=AR0()) <RPAREN> {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.REGOFFSET, arx, r);
    }
    | <STAR> arx=ARx() {
        return new C55xMemoryAccessOperand("Ymem", C55xMemoryAccessOperand.NOTMOD, arx);        
    }
}


// ARn_mod: Content of selected auxiliary register (ARn) is premodified or
// postmodified in the address generation unit.
// MISRG p.186
C55xMemoryAccessOperand ARn_mod() :
{
    C55xMemoryAccessOperand m;
}
{
    m = Smem() {
        return m;
    }
}




String RELOP() : // MISRG p. 13, 18, 630
{
    Token t;
    String op;
}
{
    (t=<EQ>|t=<LT>|t=<GE>|t=<NE>|t=<GT>|t=<LE>) {
        return t.image;
    }
    // kps - if GT or LE is encountered, what really happens
    // in the assembler is that
    // x  > y is interpreted as y <  x and
    // x <= y is interpreted as y >= x.
    // because > and <= don't exist in the hw.
}


 // 4-bit immediate shift value, 0 to 15, MISRG, p. 14
C55xImmediateOperand SHFT() :
{
    Expression expr;
}
{
    expr = Expr() {
         // (val, 4 /*bits*/, false /*unsigned*/)
        return new C55xImmediateOperand(expr.evaluate(null));
    }
}


// 6-bit immediate shift value, -32 to +31, MISRG, p. 14
C55xImmediateOperand SHIFTW() :
{
    Expression expr;
}
{
    expr = Expr() {
         // (val, 6 /*bits*/, true /*signed*/)
        return new C55xImmediateOperand(expr.evaluate(null));
    }
}



// source register, MISRG p. 14
C55xRegisterOperand dst() :
{
    C55xRegisterOperand r;
}
{
    // DR0, DR1 undocumented from example all3.asm
    (r=ACx() | r=ARx() | r=Tx())  {
        return r;
    }
}
// source or destination register (src() or dst())
C55xRegisterOperand srcdst() :
{
    C55xRegisterOperand r;
}
{
    r = dst() {
        return r;
    }
}

 // destination register, MISRG p. 13
C55xRegisterOperand src() :
{
    C55xRegisterOperand r;
}
{
    r = dst() {
        return r;
    }
}



// ACx or ACy
C55xRegisterOperand ACxy() :
{
    C55xRegisterOperand r;
}
{
    r = ACx() {
        return r;
    }
}

C55xRegisterOperand STx() : // Status register, MISRG p. 14
{
    Token t;
}
{
    (t=<ST0_55>|t=<ST1_55>|t=<ST2_55>|t=<ST3_55>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand TAx() : // Auxiliary or temporary register, MISRG p. 14
{
    C55xRegisterOperand r;
}
{
    (r=ARx()|r=Tx()) {
        return r;
    }
}

C55xBitOperand TCx() : // Test control flag, MISRG p. 14, CPUREF p. 2-38
{
    C55xBitOperand b = null;
}
{
    (b=TC1() | b=TC2()) {
        return b;
    }
}

C55xBitOperand TC1()    : { Token t; } { t=<TC1>    { return new C55xBitOperand(t.image); } }
C55xBitOperand TC2()    : { Token t; } { t=<TC2>    { return new C55xBitOperand(t.image); } }
C55xBitOperand CARRY()  : { Token t; } { t=<CARRY>  { return new C55xBitOperand(t.image); } }
C55xBitOperand BORROW() : { Token t; } { t=<BORROW> { return new C55xBitOperand(t.image); } }

C55xRegisterOperand TRNx() : // Transition register, MISRG p. 14
{
    Token t;
}
{
    (t=<TRN0>|t=<TRN1>) {
        return new C55xRegisterOperand(t.image);
    }
}

C55xRegisterOperand Tx() : // Temporary register, MISRG p. 14
{
    Token t;
}
{
    (t=<T0>|t=<T1>|t=<T2>|t=<T3>|t=<DR0>|t=<DR1>|t=<DR2>|t=<DR3>) {
        return new C55xRegisterOperand(t.image);
    } // Tx == DRx - kps - todo
}

C55xRegisterOperand XARx() : // MISRG p. 15
{
    Token t;
}
{
    (t=<XAR0>|t=<XAR1>|t=<XAR2>|t=<XAR3>|t=<XAR4>|t=<XAR5>|t=<XAR6>|t=<XAR7>) {
        return new C55xRegisterOperand(t.image);
    }
}

 // MISRG p. 15
C55xRegisterOperand XReg() :   // own definition: extended register
{
    Token t = null;
    C55xRegisterOperand r = null;
}
{
    (t=<XSP>|t=<XSSP>|t=<XDP>|t=<XCDP>|r=XARx()) {
        if (t != null)
            return new C55xRegisterOperand(t.image);
        else
            return r;
    }
}

C55xRegisterOperand XAdst() :
{
    C55xRegisterOperand r;
}
{
    r = XReg() {
        return r;
    }
}

C55xRegisterOperand XAsrc() :
{
    C55xRegisterOperand r;
}
{
    r = XReg() {
        return r;
    }
}

// MISRG p. 15
C55xRegisterOperand xdst() :
{
    C55xRegisterOperand r;
}
{
    (r=ACx() | r=XReg()) {
        return r;
    }
}

C55xRegisterOperand xsrc() : {
    C55xRegisterOperand r;
}
{
    r = xdst() {
        return r;
    }
}


C55xBitOperand fname() :
{
    Token t;
}
{
    (t=<ACOV0> | t=<ACOV1> | t=<ACOV2> | t=<ACOV3>
     | t=<CARRY> | t=<TC1> | t=<TC2>
     | t=<ASM> | t=<C54CM> | t=<FRCT>
     | t=<C16> | t=<SXMD>  | t=<SATD>
        
     | t=<M40> | t=<INTM> | t=<HM>
     | t=<XF>  | t=<CPL>  | t=<BRAF>

     | t=<AR0LC> | t=<AR1LC> | t=<AR2LC> | t=<AR3LC>
     | t=<AR4LC> | t=<AR5LC> | t=<AR6LC> | t=<AR7LC>
     | t=<CDPLC> | t=<RDM> | t=<EALLOW>  | t=<DBGM>
     | t=<ARMS>

     | t=<SST> | t=<SMUL> | t=<CLKOFF>  | t=<SATA>
     | t=<MPNMC> | t=<CBERR> | t=<HINT>
     | t=<CACLR> | t=<CAEN> | t=<CAFRZ>)  {
        return new C55xBitOperand(t.image);
    }
}

// ============================================================
// operand lists

List<Operand> ACx_ACy_ACz_ACw() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3, r4;
}
{
    // check that these are different accumulators ?
    r1=ACx() <COMMA> r2=ACx() <COMMA> r3=ACx() <COMMA> r4=ACx() {
        list.add(r1);
        list.add(r2);
        list.add(r3);
        list.add(r4);
        return list;
    }
}

List<Operand> ACx_ACy_ACz_ACw_TRNx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3, r4, r5;
}
{
    // check that these are different accumulators ?
    r1=ACx() <COMMA> r2=ACx() <COMMA> r3=ACx() <COMMA> r4=ACx() <COMMA> r5=TRNx() {
        list.add(r1);
        list.add(r2);
        list.add(r3);
        list.add(r4);
        list.add(r5);
        return list;
    }
}

List<Operand> ACx_Tx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=ACx() <COMMA> r2=Tx() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> ACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=ACx() <COMMA> r2=ACy() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> ACx_Tx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3;
}
{
    r1=ACx() <COMMA> r2=Tx() <COMMA> r3=ACy() {
        list.add(r1);
        list.add(r2);
        list.add(r3);
        return list;
    }
}

List<Operand> ACx_Tx_OPTACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3 = null;
}
{
    r1=ACx() <COMMA> r2=Tx() (<COMMA> r3=ACy())? {
        list.add(r1);
        list.add(r2);
        if (r3 != null) {
            list.add(r3);
        }
        return list;
    }
}

List<Operand> ACx_SHIFTW_OPTACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2 = null;
    C55xImmediateOperand imm;
}
{
    r1=ACx() <COMMA> <HASH> imm=SHIFTW() (<COMMA> r2=ACy())? {
        list.add(r1);
        list.add(imm);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}


// used for mac MISRG p. 256-257
List<Operand> ACxy_Tx_ACyx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3, r4;
}
{
    r1=ACxy() <COMMA> r2=Tx() <COMMA> r3=ACxy() <COMMA> r4=ACy() {
        list.add(r1);
        list.add(r2);
        list.add(r3);
        list.add(r4);
        return list;
    }
}

List<Operand> ACx_LSHIFT_Tx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3;
    C55xShiftOperand s;
}
{
    r1=ACx() <LSHIFT> r2=Tx() <COMMA> r3=ACx() {
        s = new C55xShiftOperand(r1, true, r2); // true: LSHIFT
        list.add(s);
        list.add(r3);
        return list;
    }
}

List<Operand> ACx_LSHIFT_Tx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2;
    C55xMemoryAccessOperand ma;
}
{
    r1=ACx() <LSHIFT> r2=Tx() <COMMA> ma=Smem() {
        s = new C55xShiftOperand(r1, true, r2); // true: LSHIFT
        list.add(s);
        list.add(ma);
        return list;
    }
}

List<Operand> RND_ACx_LSHIFT_Tx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2;
    C55xMemoryAccessOperand ma;
}
{
    <RND> <LPAREN> r1=ACx() <LSHIFT> r2=Tx() <RPAREN> <COMMA> ma=Smem() {
        s = new C55xShiftOperand(r1, true, r2); // true: LSHIFT
        s.setRndMod();
        list.add(s);
        list.add(ma);
        return list;
    }
}

List<Operand> ACx_LSHIFT_SHIFTW_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    r=ACx() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> ma=Smem() {
        s = new C55xShiftOperand(r, true, imm); // true: LSHIFT
        list.add(s);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand HI_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
}
{
    <HI> <LPAREN> r=ACx() <RPAREN> {
        r.setHiMod();
        return r;
    }
}

List<Operand> HI_ACx_LSHIFT_SHIFTW_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    <HI> <LPAREN> r=ACx() <LSHIFT> <HASH> imm=SHIFTW() <RPAREN> <COMMA> ma=Smem() {
        s = new C55xShiftOperand(r, true, imm); // true: LSHIFT
        s.setHiMod();
        list.add(s);
        list.add(ma);
        return list;
    }
}

C55xShiftOperand HI_ACx_LSHIFT_SHIFTW() :
{
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
    C55xShiftOperand s;
}
{
    <HI> <LPAREN> r=ACx() <LSHIFT> <HASH> imm=SHIFTW() <RPAREN> {
        s = new C55xShiftOperand(r, true, imm); // true: LSHIFT
        s.setHiMod();
        return s;
    }
}

List<Operand> rnd_HI_ACx_LSHIFT_SHIFTW_Smem() :
{
    List<Operand> list = new ArrayList<Operand>(), l = null;
    C55xMemoryAccessOperand ma = null;
    C55xShiftOperand s = null;
}
{
    (<RND> <LPAREN> s=HI_ACx_LSHIFT_SHIFTW() <RPAREN> <COMMA> ma=Smem()
     | l=HI_ACx_LSHIFT_SHIFTW_Smem()) {
        if (l != null) {
            return l;
        }
        s.setRndMod();
        list.add(s);
        list.add(ma);
        return list;
    }
}

List<Operand> ACx_LSHIFT_SHIFTW_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2;
    C55xImmediateOperand imm;
}
{
    r1=ACx() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> r2=ACx() {
        s = new C55xShiftOperand(r1, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r2);
        return list;
    }
}

List<Operand> ACx_LSHIFT_SHIFTW_OPTACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2 = null;
    C55xImmediateOperand imm;
}
{
    r1=ACx() <LSHIFT> <HASH> imm=SHIFTW() (<COMMA> r2=ACx())? {
        s = new C55xShiftOperand(r1, true, imm); // true: LSHIFT
        list.add(s);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> ACx_ACy_TCx_Tx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3;
    C55xBitOperand b;
}
{
    r1=ACx() <COMMA> r2=ACy() <COMMA> b=TCx() <COMMA> r3=Tx() {
        list.add(r1);
        list.add(r2);
        list.add(b);
        list.add(r3);
        return list;
    }
}




List<Operand> Baddr_src() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xBaddrOperand b;
    C55xRegisterOperand r;
}
{
    b = Baddr() <COMMA> r=src() {
        list.add(b);
        list.add(r);
        return list;
    }
}

List<Operand> Baddr_src_TCx() :
{
    List<Operand> list = new ArrayList<Operand>(), l;
    C55xBitOperand b;
}
{
    l = Baddr_src() <COMMA> b = TCx() {
        list.addAll(l);
        list.add(b);
        return list;
    }
}

List<Operand> BitIn_src_BitOut_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xBitOperand b1, b2;
    C55xRegisterOperand r1, r2;
}
{
    b1 = BitIn() <COMMA> r1 = src() <COMMA> b2 = BitOut() <COMMA> r2 = dst() {
        list.add(b1);
        list.add(r1);
        list.add(b2);
        list.add(r2);
        return list;
    }
}

C55xRegisterOperand CSR() :
{
    Token t;
}
{
    t=<CSR> {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> CSR_TAx() :
{
    List<Operand> list = new ArrayList<Operand>(), l;
    C55xRegisterOperand csr, tax;
}
{
    csr=CSR() <COMMA> tax=TAx() {
        list.add(csr);
        list.add(tax);
        return list;
    }
}

List<Operand> CSR_k4() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand csr;
}
{
    csr=CSR() <COMMA> imm=k4() {
        list.add(csr);
        list.add(imm);
        return list;
    }
}

C55xMemoryAccessOperand low_byte_Smem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <LOW_BYTE> <LPAREN> ma=Smem() <RPAREN> {
        ma.setLowByteMod();
        return ma;
    }
}

C55xMemoryAccessOperand uns_low_byte_Smem() :
{
    C55xMemoryAccessOperand s=null, u=null;
}
{
    (s=low_byte_Smem() | <UNS> <LPAREN> u=low_byte_Smem() <RPAREN>) {
        if (s != null) {
            return s; // nothing to do
        }
        u.setUnsMod();
        return u;
    }
}

List<Operand> low_byte_Smem_LSHIFT_SHIFTW_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    ma=low_byte_Smem() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> r=ACx() {
        s = new C55xShiftOperand(ma, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}

C55xMemoryAccessOperand high_byte_Smem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <HIGH_BYTE> <LPAREN> ma=Smem() <RPAREN> {
        ma.setHighByteMod();
        return ma;
    }
}

List<Operand> high_byte_Smem_LSHIFT_SHIFTW_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    ma=high_byte_Smem() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> r=ACx() {
        s = new C55xShiftOperand(ma, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}
C55xMemoryAccessOperand UNS_high_byte_Smem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <UNS> <LPAREN> ma=high_byte_Smem() <RPAREN> {
        ma.setUnsMod();
        return ma;
    }
}

C55xMemoryAccessOperand uns_high_byte_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
}
{
    (ma=high_byte_Smem() | ma=UNS_high_byte_Smem()) {
        return ma;
    }
}


List<Operand> uns_high_byte_Smem_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma = uns_high_byte_Smem() <COMMA> r = dst() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> uns_low_byte_Smem_dst() :
{
    List<Operand> list = new ArrayList<Operand>(), l;
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma = uns_low_byte_Smem() <COMMA> r = dst() {
        list.add(ma);
        list.add(r);
        return list;
    }
}


List<Operand> src_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1 = src() <COMMA> r2 = dst() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> xsrc_xdst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1 = xsrc() <COMMA> r2 = xdst() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> src1_src2() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1 = src() <COMMA> r2 = src() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> dst1_dst2() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1 = dst() <COMMA> r2 = dst() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> dst_1() :
{
    List<Operand> list = new ArrayList<Operand>(), l1;
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
}
{
    // Expr() must equal 1 or -1
    r = dst() <COMMA> imm = Literal() {
        list.add(r); 
        list.add(imm);
        return list;
    }
}

List<Operand> src_RELOP_dst_TCx() :
{
    List<Operand> list = new ArrayList<Operand>(), l1, l2, l3, l4;
    C55xRegisterOperand sr, dr;
    C55xBitOperand b;
    C55xRelOpOperand ro;
    String op;
}
{
    sr = src() op = RELOP() dr = dst() <COMMA> b = TCx() {
        ro = new C55xRelOpOperand(sr, op, dr);
        list.add(ro);
        list.add(b);
        return list;
    }
}

List<Operand> src_RELOP_dst_OPTBANG_TCy_TCx() :
{
    List<Operand> list = new ArrayList<Operand>(), l1, l2, l3;
    Token bang = null, t1, t2;
    C55xBitOperand tcx, tcy;
    C55xRegisterOperand r1, r2;
    C55xRelOpOperand ro;
    String op;
}
{
    r1 = src() op = RELOP() r2 = dst() <COMMA>
        (bang = <BANG>)?
        ((tcx=TC1() <COMMA> tcy=TC2())
         |(tcx=TC2() <COMMA> tcy=TC1())) {
        // r1 op r2 should be one operand
        ro = new C55xRelOpOperand(r1, op, r2);
        list.add(ro);

        if (bang != null) {
            tcx.setNotMod();
        }
        list.add(tcx);
        list.add(tcy);
        return list;
    }
}

List<Operand> L8_src_RELOP_K8() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm1, imm2;
    C55xRegisterOperand r;
    C55xRelOpOperand ro;
    String op;
}
{
    imm1 = L8() <COMMA> r = src() op = RELOP() imm2 = K8() {
        list.add(imm1);
        ro = new C55xRelOpOperand(r, op, imm2);
        list.add(ro);
        return list;
    }
}

// [src,] dst
List<Operand> OPTsrc_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2 = null;
}
{
    r1 = srcdst() (<COMMA> r2 = srcdst())? {
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// K16, [src,] dst
List<Operand> K16_OPTsrc_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=K16() <COMMA> r1=srcdst() (<COMMA> r2=srcdst())? {
        list.add(imm);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// k8|k16, [src,] dst
List<Operand> k8k16_OPTsrc_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=k16() <COMMA> r1=srcdst() (<COMMA> r2=srcdst())? {
        list.add(imm);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// k4K16, [src,] dst
List<Operand> k4K16_OPTsrc_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2 = null;
}
{
    // kps todo - check for k4 here ??
    imm=K16() <COMMA> r1=srcdst() (<COMMA> r2=srcdst())? {
        list.add(imm);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> K16_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    imm=K16() <COMMA> ma=Smem() {
        list.add(imm);
        list.add(ma);
        return list;
    }
}

List<Operand> K16_LSHIFT_16_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, imm2; // imm2 = 16
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    imm=K16() <LSHIFT> imm2=Literal16() <COMMA> r=ACx() {
        s = new C55xShiftOperand(imm, true, imm2); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> K16_LSHIFT_SHFT_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, shft;
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    imm=K16() <LSHIFT> <HASH> shft=SHFT() <COMMA> r=ACx() {
        s = new C55xShiftOperand(imm, true, shft); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> k16_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    imm=k16() <COMMA> ma=Smem() {
        list.add(imm);
        list.add(ma);
        return list;
    }
}

List<Operand> k16_ACx_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2;
}
{
    imm=k16() <COMMA> r1=ACx() <COMMA> r2=dst() {
        list.add(imm);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> K8K16_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    imm=K8K16() <COMMA> ma=Smem() {
        list.add(imm);
        list.add(ma);
        return list;
    }
}

List<Operand> k8k16_src_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2;
}
{
    // kps todo - check that imm is 8 or 16 bit ???
    imm=k8k16() <COMMA> r1=src() <COMMA> r2=dst() {
        list.add(imm);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> k4_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k4() <COMMA> r=dst() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

List<Operand> k4_Smem_TCx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
    C55xBitOperand b;
}
{
    imm=k4() <COMMA> ma=Smem() <COMMA> b=TCx() {
        list.add(imm);
        list.add(ma);
        list.add(b);
        return list;
    }
}

List<Operand> k4_STx() :
{ List<Operand> list = new ArrayList<Operand>(); }
{
    (LOOKAHEAD(k4() <COMMA> STx())
    k4() <COMMA> STx()
        // special hack for bset and bclr
        | (<HASH>)? fname() <COMMA> STx()) // e.g. BSET #FRCT, ST1_55 
        { return list; /* kps todo */ }
}

List<Operand> Smem_src_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    ma=Smem() <COMMA> r1=src() <COMMA> r2=dst() {
        list.add(ma);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> Smem_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=Smem() <COMMA> r=dst() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> Smem_EQ_K16_TCx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm;
    C55xBitOperand b;
    C55xRelOpOperand ro;
    Token t;
}
{
    ma=Smem() t=<EQ> imm=K16() <COMMA> b=TCx() {
        ro = new C55xRelOpOperand(ma, t.image, imm);
        list.add(ro);
        list.add(b);
        return list;
    }
}

List<Operand> src_Smem_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
    C55xMemoryAccessOperand ma;
}
{
    r1=src() <COMMA> ma=Smem() <COMMA> r2=dst() {
        list.add(r1);
        list.add(ma);
        list.add(r2);
        return list;
    }
}

List<Operand> src_Smem_TCx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
    C55xBitOperand b;
}
{
    r=src() <COMMA> ma=Smem() <COMMA> b=TCx() {
        list.add(r);
        list.add(ma);
        list.add(b);
        return list;
    }
}

List<Operand> src_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=src() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> src_high_byte_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=src() <COMMA> <HIGH_BYTE> <LPAREN> ma=Smem() <RPAREN> {
        list.add(r);
        ma.setHighByteMod();
        list.add(ma);
        return list;
    }
}

List<Operand> src_low_byte_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=src() <COMMA> <LOW_BYTE> <LPAREN> ma=Smem() <RPAREN> {
        list.add(r);
        ma.setLowByteMod();
        list.add(ma);
        return list;
    }
}

List<Operand> dst_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=dst() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand DBL_ACx() :
{
    C55xRegisterOperand r;
}
{
    <DBL> <LPAREN> r=ACx() <RPAREN> {
        r.setDblMod();
        return r;
    }
}

C55xMemoryAccessOperand DBL_Lmem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <DBL> <LPAREN> ma=Lmem() <RPAREN> {
        ma.setDblMod();
        return ma;
    }
}

C55xMemoryAccessOperand DBL_Xmem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <DBL> <LPAREN> ma=Xmem() <RPAREN> {
        ma.setDblMod();
        return ma;
    }
}

C55xMemoryAccessOperand DBL_Ymem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <DBL> <LPAREN> ma=Ymem() <RPAREN> {
        ma.setDblMod();
        return ma;
    }
}

List<Operand> DBL_Xmem_DBL_Ymem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
}
{
    x=DBL_Xmem() <COMMA> y=DBL_Ymem() {
        list.add(x);
        list.add(y);
        return list;
    }
}

List<Operand> DBL_Lmem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=DBL_Lmem() <COMMA> r=ACx() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> ACx_DBL_Lmem_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    r1=ACx() <COMMA> ma=DBL_Lmem() <COMMA> r2=ACy() {
        list.add(r1);
        list.add(ma);
        list.add(r2);
        return list;
    }
}

List<Operand> XAsrc_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    r=XAsrc() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> DBL_Lmem_XAdst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=DBL_Lmem() <COMMA> r=XAdst() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

// dbl(Lmem), [ACx,] ACy
List<Operand> DBL_Lmem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=DBL_Lmem() <COMMA> r1=ACxy() (<COMMA> r2=ACxy())? {
        list.add(ma);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

C55xRegisterOperand PAIR_TAx() :
{
    C55xRegisterOperand r;
}
{
    <PAIR> <LPAREN> r=TAx() <RPAREN> {
        r.setPairMod();
        return r;
    }
}

List<Operand> DBL_Lmem_PAIR_TAx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=DBL_Lmem() <COMMA> r=PAIR_TAx() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> ACx_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    r=ACx() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand PAIR_LO_ACx() :
{
    C55xRegisterOperand r;
}
{
    <PAIR> <LPAREN> <LO> <LPAREN> r=ACx() <RPAREN> <RPAREN> {
        r.setPairMod();
        r.setLoMod();
        return r;
    }
}

C55xRegisterOperand RND_HI_ACx() :
{
    C55xRegisterOperand r;
}
{
    <RND> <LPAREN> r=HI_ACx() <RPAREN> {
        r.setRndMod();
        return r;
    }
}

List<Operand> RND_HI_ACx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=RND_HI_ACx() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}


C55xRegisterOperand rnd_HI_ACx() :
{
    C55xRegisterOperand r = null;
}
{
    (r=HI_ACx() | r=RND_HI_ACx()) {
        return r;
    }
}

List<Operand> rnd_HI_ACx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=rnd_HI_ACx() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xShiftOperand HI_ACx_LSHIFT_Tx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
    C55xShiftOperand s;
}
{
    <HI> <LPAREN> r1=ACx() <LSHIFT> r2=Tx() <RPAREN> {
        s = new C55xShiftOperand(r1, true, r2); // true: LSHIFT
        s.setHiMod();
        return s;
    }
}

C55xShiftOperand RND_HI_ACx_LSHIFT_Tx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
}
{
    <RND> <RPAREN> s=HI_ACx_LSHIFT_Tx() <LPAREN> {
        s.setHiMod();
        return s;
    }
}

C55xShiftOperand rnd_HI_ACx_LSHIFT_Tx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s = null;
}
{
    (s=RND_HI_ACx_LSHIFT_Tx() | s=HI_ACx_LSHIFT_Tx())  {
        return s;
    }
}

List<Operand> rnd_HI_ACx_LSHIFT_Tx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xMemoryAccessOperand ma;
}
{
    s=rnd_HI_ACx_LSHIFT_Tx() <COMMA> ma=Smem() {
        list.add(s);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand PAIR_HI_ACx() :
{
    C55xRegisterOperand r;
}
{
    <PAIR> <LPAREN> r=HI_ACx() <RPAREN> {
        r.setPairMod();
        return r;
    }
}

List<Operand> PAIR_HI_ACx_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=PAIR_HI_ACx() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> PAIR_LO_ACx_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=PAIR_LO_ACx() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> PAIR_TAx_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=PAIR_TAx() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> HI_ACx_TAx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=HI_ACx() <COMMA> r2=TAx() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> HI_ACx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=HI_ACx() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

List<Operand> TAx_HI_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=TAx() <COMMA> r2=HI_ACx() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> DBL_Lmem_PAIR_HI_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    ma=DBL_Lmem() <COMMA> r=PAIR_HI_ACx() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> DBL_Lmem_PAIR_LO_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    ma=DBL_Lmem() <COMMA> r=PAIR_LO_ACx() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

C55xMemoryAccessOperand DUAL_Lmem() :
{
    C55xMemoryAccessOperand ma;
}
{
    <DUAL> <LPAREN> ma=Lmem() <RPAREN> {
        ma.setDualMod();
        return ma;
    }
}

List<Operand> DUAL_Lmem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=DUAL_Lmem() <COMMA> r1=ACxy() (<COMMA> r2=ACxy())? {
        list.add(ma);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> ACx_DUAL_Lmem_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    r1=ACx() <COMMA> ma=DUAL_Lmem() <COMMA> r2=ACy() {
        list.add(r1);
        list.add(ma);
        list.add(r2);
        return list;
    }
}

List<Operand> DUAL_Lmem_Tx_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    ma=DUAL_Lmem() <COMMA> r1=Tx() <COMMA> r2=ACx() {
        list.add(ma);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> ACx_RSHIFT_1_DUAL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xImmediateOperand imm; // =1
    C55xMemoryAccessOperand ma;
    C55xShiftOperand s;
}
{
    r=ACx() <RSHIFT> imm=Literal() <COMMA> ma=DUAL_Lmem() {
        s = new C55xShiftOperand(r, false, imm); // false: RSHIFT
        list.add(s);
        list.add(ma);
        return list;
    }
}


List<Operand> Smem_k16_TCx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xBitOperand b;
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
}
{
    ma=Smem() <COMMA> imm=k16() <COMMA> b=TCx() {
        list.add(ma);
        list.add(imm);
        list.add(b);
        return list;
    }
}

List<Operand> Smem_XAdst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=Smem() <COMMA> r=XAdst() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> Smem_ACx_TCx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
    C55xBitOperand b;
}
{
    ma=Smem() <COMMA> r1=ACx() <COMMA> b=TCx() <COMMA> r2=ACy() {
        list.add(ma);
        list.add(r1);
        list.add(b);
        list.add(r2);
        return list;
    }
}

List<Operand> Smem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=Smem() <COMMA> r1=ACxy() (<COMMA> r2=ACxy())? {
        list.add(ma);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> ACx_TCx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xBitOperand b;
}
{
    r=ACx() <COMMA> b=TCx() {
        list.add(r);
        list.add(b);
        return list;
    }
}

List<Operand> Smem_ACx_TC1_TC2_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
    C55xBitOperand b1, b2;
}
{
    ma=Smem() <COMMA> r1=ACx() <COMMA> b1=TC1() <COMMA> b2=TC2() <COMMA> r2=ACy() {
        list.add(ma);
        list.add(r1);
        list.add(b1);
        list.add(b2);
        list.add(r2);
        return list;
    }
}

List<Operand> Smem_ACx_Tx_TC1_TC2_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2, r3;
    C55xBitOperand b1, b2;
}
{
    ma=Smem() <COMMA> r1=ACx() <COMMA> r2=Tx() <COMMA> b1=TC1() <COMMA> b2=TC2() <COMMA> r3=ACy() {
        list.add(ma);
        list.add(r1);
        list.add(r2);
        list.add(b1);
        list.add(b2);
        list.add(r3);
        return list;
    }
}

C55xRegisterOperand REG19() :
{
    Token t;
}
{
    (t=<BK03>|t=<BK47>|t=<BKC>
     |t=<BSA01>|t=<BSA23>|t=<BSA45>|t=<BSA67>|t=<BSAC>
     |t=<BRC0>|t=<BRC1>
     |t=<CDP>|t=<CSR>|t=<DP>|t=<DPH>|t=<PDP>
     |t=<SP>|t=<SSP>|t=<TRN0>|t=<TRN1>) {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> Smem_REG19() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=Smem() <COMMA> r=REG19() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> REG19_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=REG19() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand RETA() :
{
    C55xRegisterOperand r;
    Token t;
}
{
    t=<RETA> {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> RETA_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=RETA() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xRegisterOperand REGLIST1() :
{
    Token t;
}
{
    (t=<BK03>|t=<BK47>|t=<BKC>|t=<BRC0>|t=<BRC1>|t=<CSR>) {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> k12_REGLIST1() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k12() <COMMA> r=REGLIST1() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

C55xRegisterOperand DPH() :
{
    Token t;
}
{
    t=<DPH> {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> k7_DPH() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k7() <COMMA> r=DPH() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

C55xRegisterOperand PDP() :
{
    Token t;
}
{
    t=<PDP> {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> k9_PDP() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k9() <COMMA> r=PDP() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

C55xRegisterOperand REG9() :
{
    Token t;
}
{
    (t=<BSA01>|t=<BSA23>|t=<BSA45>|t=<BSA67>|t=<BSAC>|t=<CDP>|t=<DP>|t=<SP>|t=<SSP>) {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> k16_REG9() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k16() <COMMA> r=REG9() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

C55xRegisterOperand REGLIST2() :
{
    Token t;
}
{
    (t=<BRC0>|t=<BRC1>|t=<CDP>|t=<CSR>|t=<SP>|t=<SSP>) {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> TAx_REGLIST2() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=TAx() <COMMA> r2=REGLIST2() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

C55xRegisterOperand REGLIST3() :
{
    Token t;
}
{
    (t=<BRC0>|t=<BRC1>|t=<CDP>|t=<SP>|t=<SSP>|t=<RPTC>) {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> REGLIST3_TAx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    r1=REGLIST3() <COMMA> r2=TAx() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> DBL_Lmem_RETA() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=DBL_Lmem() <COMMA> r=RETA() {
        list.add(ma);
        list.add(r);
        return list;
    }
}


List<Operand> Tx_DUAL_Lmem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    r1=Tx() <COMMA> ma=DUAL_Lmem() <COMMA> r2=ACx() {
        list.add(r1);
        list.add(ma);
        list.add(r2);
        return list;
    }
}

List<Operand> Tx_Smem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2;
}
{
    r1=Tx() <COMMA> ma=Smem() <COMMA> r2=ACx() {
        list.add(r1);
        list.add(ma);
        list.add(r2);
        return list;
    }
}

List<Operand> Tx_K8K16_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3 = null;
    C55xImmediateOperand imm;
}
{
    r1=Tx() <COMMA> imm=K8K16() <COMMA> r2=ACx() (<COMMA> r3=ACy())? {
        list.add(r1);
        list.add(imm);
        list.add(r2);
        if (r3 != null) {
            list.add(r3);
        }
        return list;
    }
}

List<Operand> K8K16_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2 = null;
    C55xImmediateOperand imm;
}
{
    imm=K8K16() <COMMA> r1=ACx() (<COMMA> r2=ACy())? {
        list.add(imm);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}


List<Operand> Smem_OPTsrc_dst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2 = null;
    C55xMemoryAccessOperand ma;
}
{
    ma=Smem() <COMMA> r1=srcdst() (<COMMA> r2=srcdst())? {
        list.add(ma);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}


List<Operand> TAx_TAy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2;
}
{
    // x != y ?
    r1 = TAx() <COMMA> r2 = TAx() {
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> P8_TAx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
}
{
    imm = P8() <COMMA> r = TAx() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

// P8 or D16
List<Operand> P8D16_TAx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
}
{
    imm=Literal() <COMMA> r=TAx() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

C55xRegisterOperand SP() :
{
    Token t;
}
{
    t=<SP> {
        return new C55xRegisterOperand(t.image);
    }
}

List<Operand> K8_SP() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand sp;
}
{
    imm=K8() <COMMA> sp=SP() {
        list.add(imm);
        list.add(sp);
        return list;
    }
}

List<Operand> k8_cond() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xConditionFieldOperand cf;
}
{
    imm=k8() <COMMA> cf=cond() {
        list.add(imm);
        list.add(cf);
        return list;
    }
}

List<Operand> k23_XAdst() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
}
{
    imm=k23() <COMMA> r=XAdst() {
        list.add(imm);
        list.add(r);
        return list;
    }
}

List<Operand> OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2 = null;
}
{
    r1=ACxy() (<COMMA> r2=ACxy())? {
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> Cmem_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand c, s;
}
{
    c=Cmem() <COMMA> s=Smem() {
        list.add(c);
        list.add(s);
        return list;
    }
}

List<Operand> Cmem_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand c, l;
}
{
    c=Cmem() <COMMA> l=DBL_Lmem() {
        list.add(c);
        list.add(l);
        return list;
    }
}

List<Operand> DBL_Lmem_Cmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand l, c;
}
{
    l=DBL_Lmem() <COMMA> c=Cmem() {
        list.add(l);
        list.add(c);
        return list;
    }
}

List<Operand> Smem_Cmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s, c;
}
{
    s=Smem() <COMMA> c=Cmem() {
        list.add(s);
        list.add(c);
        return list;
    }
}

List<Operand> Xmem_Ymem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
}
{
    x=Xmem() <COMMA> y=Ymem() {
        list.add(x);
        list.add(y);
        return list;
    }
}

List<Operand> ACx_Xmem_Ymem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand x, y;
}
{
    r=ACx() <COMMA> x=Xmem() <COMMA> y=Ymem() {
        list.add(r);
        list.add(x);
        list.add(y);
        return list;
    }
}

List<Operand> Xmem_Ymem_ACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
    C55xRegisterOperand r1, r2;
}
{
    x=Xmem() <COMMA> y=Ymem() <COMMA> r1=ACx() <COMMA> r2=ACx() {
        list.add(x);
        list.add(y);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> Xmem_Ymem_Cmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y, c;
}
{
    x=Xmem() <COMMA> y=Ymem() <COMMA> c=Cmem() {
        list.add(x);
        list.add(y);
        list.add(c);
        return list;
    }
}

List<Operand> Xmem_Ymem_Cmem_ACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y, c;
    C55xRegisterOperand r1, r2;
}
{
    x=Xmem() <COMMA> y=Ymem() <COMMA> c=Cmem() <COMMA> r1=ACx() <COMMA> r2=ACx() {
        list.add(x);
        list.add(y);
        list.add(c);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

// K16 << #16, [ACx,] ACy
List<Operand> K16_LSHIFT_16_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, imm2; // imm2 = 16
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=K16() <LSHIFT> imm2=Literal16() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(imm, true, imm2);
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// k16 << #16, [ACx,] ACy
List<Operand> k16_LSHIFT_16_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, imm2; // imm2 = 16
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=k16() <LSHIFT> imm2=Literal16() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(imm, true, imm2);
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> K16_LSHIFT_SHFT_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, shft;
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=K16() <LSHIFT> <HASH> shft=SHFT() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(imm, true, shft);
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// same as above, but k16 instead of K16, sigh
List<Operand> k16_LSHIFT_SHFT_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm, shft;
    C55xShiftOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    imm=k16() <LSHIFT> <HASH> shft=SHFT() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(imm, true, shft);
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// Smem << Tx, [ACx,] ACy
List<Operand> Smem_LSHIFT_Tx_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2, r3 = null;
    C55xShiftOperand s;
}
{
    ma=Smem() <LSHIFT> r1=Tx() <COMMA> r2=ACxy() (<COMMA> r3=ACxy()) ? {
        s = new C55xShiftOperand(ma, true, r1); // true: lshift
        list.add(s);
        list.add(r2);
        if (r3 != null) {
            list.add(r3);
        }
        return list;
    }
}

List<Operand> Smem_LSHIFT_16_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm; // 16
    C55xRegisterOperand r1, r2 = null;
    C55xShiftOperand s;
}
{
    ma=Smem() <LSHIFT> imm=Literal() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(ma, true, imm); // true: lshift
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> Smem_LSHIFT_16_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm; // 16
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    ma=Smem() <LSHIFT> imm=Literal() <COMMA> r=ACx() {
        s = new C55xShiftOperand(ma, true, imm); // true: lshift
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> ACx_Smem_LSHIFT_16_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm; // 16
    C55xRegisterOperand r1, r2;
    C55xShiftOperand s;    
}
{
    r1=ACx() <COMMA> ma=Smem() <LSHIFT> imm=Literal() <COMMA> r2=ACy() {
        list.add(r1);
        s = new C55xShiftOperand(ma, true, imm); // true: lshift
        list.add(s);
        list.add(r2);
        return list;
    }
}


boolean OPTT3EQ() :
{
    List<Operand> list = new ArrayList<Operand>();
    Token t3 = null, eq = null;
}
{
    (t3=<T3> eq=<EQ1>)? {
        return ((t3 != null && eq != null) ? true : false);
    }
}

C55xMemoryAccessOperand OPTT3EQ_Smem() :
{
    boolean t3eq;
    C55xMemoryAccessOperand s;
}
{
    t3eq=OPTT3EQ() s=Smem() {
        if (t3eq) {
            s.setT3EQ();
        }
        return s;
    }
}

List<Operand> OPTT3EQ_Smem_Cmem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s, c;
    C55xRegisterOperand r;
}
{
    s=OPTT3EQ_Smem() <COMMA> c=Cmem() <COMMA> r=ACx() {
        list.add(s);
        list.add(c);
        list.add(r);
        return list;
    }
}

List<Operand> OPTT3EQ_Smem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    s=OPTT3EQ_Smem() <COMMA> r1=ACx() (<COMMA> r2=ACx())? {
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> OPTT3EQ_Smem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r;
}
{
    s=OPTT3EQ_Smem() <COMMA> r=ACx() {
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> OPTT3EQ_Smem_Tx_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r1, r2, r3 = null;
}
{
    s=OPTT3EQ_Smem() <COMMA> r1=Tx() <COMMA> r2=ACx() (<COMMA> r3=ACx())? {
        list.add(s);
        list.add(r1);
        list.add(r2);
        if (r3 != null) {
            list.add(r3);
        }
        return list;
    }
}

List<Operand> OPTT3EQ_Smem_Tx_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r1, r2;
}
{
    s=OPTT3EQ_Smem() <COMMA> r1=Tx() <COMMA> r2=ACx() {
        list.add(s);
        list.add(r1);
        list.add(r2);
        return list;
    }
}



List<Operand> OPTT3EQ_Smem_K8_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r1, r2 = null;
}
{
    s=OPTT3EQ_Smem() <COMMA> imm=K8() <COMMA> r1=ACx() (<COMMA> r2=ACx())? {
        list.add(s);
        list.add(imm);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> OPTT3EQ_Smem_K8_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand s;
    C55xRegisterOperand r;
}
{
    s=OPTT3EQ_Smem() <COMMA> imm=K8() <COMMA> r=ACx() {
        list.add(s);
        list.add(imm);
        list.add(r);
        return list;
    }
}


C55xMemoryAccessOperand UNS_Smem() :
{
    C55xMemoryAccessOperand s;
}
{
    <UNS> <LPAREN> s=Smem() <RPAREN> {
        s.setUnsMod();
        return s;
    }
}

C55xMemoryAccessOperand unsSmem() :
{
    C55xMemoryAccessOperand s;
}
{
    (s=Smem() | s=UNS_Smem()) {
        return s;
    }
}

C55xMemoryAccessOperand UNS_Xmem() :
{
    C55xMemoryAccessOperand x;
}
{
    <UNS> <LPAREN> x=Xmem() <RPAREN> {
        x.setUnsMod();
        return x;
    }
}

C55xMemoryAccessOperand unsXmem() :
{
    C55xMemoryAccessOperand x;
}
{
    (x=Xmem() | x=UNS_Xmem()) {
        return x;
    }
}

C55xMemoryAccessOperand UNS_Ymem() :
{
    C55xMemoryAccessOperand y;
}
{
    <UNS> <LPAREN> y=Ymem() <RPAREN> {
        y.setUnsMod();
        return y;
    }
}

C55xMemoryAccessOperand unsYmem() :
{
    C55xMemoryAccessOperand y;
}
{
    (y=Ymem() | y=UNS_Ymem()) {
        return y;
    }
}


C55xMemoryAccessOperand UNS_Cmem() :
{
    C55xMemoryAccessOperand c;
}
{
    <UNS> <LPAREN> c=Cmem() <RPAREN> {
        c.setUnsMod();
        return c;
    }
}

C55xMemoryAccessOperand unsCmem() :
{
    C55xMemoryAccessOperand c;
}
{
    (c=Cmem() | c=UNS_Cmem()) {
        return c;
    }
}


C55xMemoryAccessOperand OPTT3EQ_unsXmem() :
{
    boolean t3eq;
    C55xMemoryAccessOperand x;
}
{
    t3eq=OPTT3EQ() x=unsXmem() {
        if (t3eq) {
            x.setT3EQ();
        }
        return x;
    }
}

C55xMemoryAccessOperand OPTT3EQ_Xmem() :
{
    boolean t3eq;
    C55xMemoryAccessOperand x;
}
{
    t3eq=OPTT3EQ() x=Xmem() {
        if (t3eq) {
            x.setT3EQ();
        }
        return x;
    }
}


List<Operand> OPTT3EQ_unsXmem_unsYmem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
    C55xRegisterOperand r1, r2 = null;
}
{
    x=OPTT3EQ_unsXmem() <COMMA> y=unsYmem() <COMMA> r1=ACx() (<COMMA> r2=ACx())? {
        list.add(x);
        list.add(y);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> OPTT3EQ_unsXmem_unsYmem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
    C55xRegisterOperand r;
}
{
    x=OPTT3EQ_unsXmem() <COMMA> y=unsYmem() <COMMA> r=ACx() {
        list.add(x);
        list.add(y);
        list.add(r);
        return list;
    }
}

List<Operand> OPTT3EQ_unsXmem_unsYmem_ACx_RSHIFT_16_OPTACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
    C55xRegisterOperand r1, r2 = null;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    x=OPTT3EQ_unsXmem() <COMMA> y=unsYmem()
        <COMMA> r1=ACx() <RSHIFT> imm=Literal() (<COMMA> r2=ACx())? {
            list.add(x);
            list.add(y);
            s = new C55xShiftOperand(r1, false, imm); // false: RSHIFT
            list.add(s);
            if (r2 != null) {
                list.add(r2);
            }
            return list;
        }
}

/*
C55xLabelOperand label() :
{
    C55xLabelOperand l;
}
{
    
}

C55xLabelOperand OPTlabel() :
{
    C55xLabelOperand l = null;
}
{
    LOOKAHEAD((label() <COMMA>)?)
        (l = label() <COMMA>)? {
        return l;
    }
}

List<Operand> OPTlabel_cond() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xConditionFieldOperand c;
    C55xLabelOperand l = null;
}
{
    l=OPTlabel() c=cond() {
        if (l != null) {
            list.add(l);
        }
        list.add(c);
        return list;
    }
}
*/

    // kps - this is really [label, ] cond,
    // but in the disassembly, there always is just the cond
List<Operand> OPTlabel_cond() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xConditionFieldOperand c;
}
{
    c = cond() {
        list.add(c);
        return list;
    }
}


C55xRegisterOperand SATURATE_ACx() :
{
    C55xRegisterOperand r;
}
{
    <SATURATE> <LPAREN> r=ACx() <RPAREN> {
        r.setSaturateMod();
        return r;
    }
}

C55xRegisterOperand saturateACx() :
{
    C55xRegisterOperand r;
} 
{   
    (r=ACx() | r=SATURATE_ACx()) {
        return r;
    }
}

C55xRegisterOperand HI_saturateACx() :
{
    C55xRegisterOperand r;
}
{
    <HI> <LPAREN> r=saturateACx() <RPAREN> {
        r.setHiMod();
        return r;
    }
}


C55xRegisterOperand RND_HI_saturateACx() :
{
    C55xRegisterOperand r;
}
{
    <RND> <LPAREN> r=HI_saturateACx() <RPAREN> {
        r.setRndMod();
        return r;
    }
}

C55xRegisterOperand rnd_HI_saturateACx() :
{
    C55xRegisterOperand r;
}
{
    (r=HI_saturateACx() | r=RND_HI_saturateACx()) {
        return r;
    }
}

C55xRegisterOperand UNS_rnd_HI_saturateACx() :
{
     C55xRegisterOperand r;
}
{
    <UNS> <LPAREN> r=rnd_HI_saturateACx() <RPAREN> {
        r.setUnsMod();
        return r;
    }
}

C55xRegisterOperand uns_rnd_HI_saturateACx() :
{
    C55xRegisterOperand r;
}
{
    (r=rnd_HI_saturateACx() | r=UNS_rnd_HI_saturateACx()) {
        return r;
    }
}

List<Operand> uns_rnd_HI_saturateACx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=uns_rnd_HI_saturateACx() <COMMA> ma=Smem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}

C55xShiftOperand ACxLSHIFT_Tx() :
{
    C55xRegisterOperand r1, r2;
}
{
    r1=ACx() <LSHIFT> r2=Tx() {
        return new C55xShiftOperand(r1, true, r2); // true: LSHIFT
    }
}


C55xShiftOperand SATURATE_ACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    <SATURATE> <LPAREN> s=ACxLSHIFT_Tx() <RPAREN> {
        s.setSaturateMod();
        return s;
    }
}

C55xShiftOperand saturateACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    (s=SATURATE_ACxLSHIFT_Tx() | s=ACxLSHIFT_Tx()) {
        return s;
    }
}

C55xShiftOperand HI_saturateACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    <HI> <LPAREN> s=saturateACxLSHIFT_Tx() <RPAREN> {
        s.setHiMod();
        return s;
    }
}


C55xShiftOperand RND_HI_saturateACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    <RND> <LPAREN> s=HI_saturateACxLSHIFT_Tx() <RPAREN> {
        s.setRndMod();
        return s;
    }
}

C55xShiftOperand rnd_HI_saturateACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    (s=HI_saturateACxLSHIFT_Tx() | s=RND_HI_saturateACxLSHIFT_Tx()) {
        return s;
    }
}

C55xShiftOperand UNS_rnd_HI_saturateACxLSHIFT_Tx() :
{
     C55xShiftOperand s;
}
{
    <UNS> <LPAREN> s=rnd_HI_saturateACxLSHIFT_Tx() <RPAREN> {
        s.setUnsMod();
        return s;
    }
}

C55xShiftOperand uns_rnd_HI_saturateACxLSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    (s=rnd_HI_saturateACxLSHIFT_Tx() | s=UNS_rnd_HI_saturateACxLSHIFT_Tx()) {
        return s;
    }
}

List<Operand> uns_rnd_HI_saturateACxLSHIFT_Tx_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xMemoryAccessOperand ma;
}
{
    s=uns_rnd_HI_saturateACxLSHIFT_Tx() <COMMA> ma=Smem() {
        list.add(s);
        list.add(ma);
        return list;
    }
}


C55xShiftOperand ACxLSHIFT_SHIFTW() :
{
    C55xRegisterOperand r;
    C55xImmediateOperand imm;
}
{
    r=ACx() <LSHIFT> <HASH> imm=SHIFTW() {
        return new C55xShiftOperand(r, true, imm); // true: LSHIFT
    }
}


C55xShiftOperand SATURATE_ACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    <SATURATE> <LPAREN> s=ACxLSHIFT_SHIFTW() <RPAREN> {
        s.setSaturateMod();
        return s;
    }
}

C55xShiftOperand saturateACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    (s=SATURATE_ACxLSHIFT_SHIFTW() | s=ACxLSHIFT_SHIFTW()) {
        return s;
    }
}

C55xShiftOperand HI_saturateACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    <HI> <LPAREN> s=saturateACxLSHIFT_SHIFTW() <RPAREN> {
        s.setHiMod();
        return s;
    }
}


C55xShiftOperand RND_HI_saturateACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    <RND> <LPAREN> s=HI_saturateACxLSHIFT_SHIFTW() <RPAREN> {
        s.setRndMod();
        return s;
    }
}

C55xShiftOperand rnd_HI_saturateACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    (s=HI_saturateACxLSHIFT_SHIFTW() | s=RND_HI_saturateACxLSHIFT_SHIFTW()) {
        return s;
    }
}

C55xShiftOperand UNS_rnd_HI_saturateACxLSHIFT_SHIFTW() :
{
     C55xShiftOperand s;
}
{
    <UNS> <LPAREN> s=rnd_HI_saturateACxLSHIFT_SHIFTW() <RPAREN> {
        s.setUnsMod();
        return s;
    }
}

C55xShiftOperand uns_rnd_HI_saturateACxLSHIFT_SHIFTW() :
{
    C55xShiftOperand s;
}
{
    (s=rnd_HI_saturateACxLSHIFT_SHIFTW() | s=UNS_rnd_HI_saturateACxLSHIFT_SHIFTW()) {
        return s;
    }
}

List<Operand> uns_rnd_HI_saturateACxLSHIFT_SHIFTW_Smem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xMemoryAccessOperand ma;
}
{
    s=uns_rnd_HI_saturateACxLSHIFT_SHIFTW() <COMMA> ma=Smem() {
        list.add(s);
        list.add(ma);
        return list;
    }
}




C55xRegisterOperand UNS_SATURATE_ACx() :
{
    C55xRegisterOperand r;
}
{
    <UNS> <LPAREN> r=SATURATE_ACx() <RPAREN> {
        r.setUnsMod();
        return r;
    }
}

C55xRegisterOperand uns_SATURATE_ACx() :
{
    C55xRegisterOperand r;
}
{
    (r=SATURATE_ACx() | r=UNS_SATURATE_ACx()) {
        return r;
    }
}

List<Operand> uns_SATURATE_ACx_DBL_Lmem() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r;
    C55xMemoryAccessOperand ma;
}
{
    r=uns_SATURATE_ACx() <COMMA> ma=DBL_Lmem() {
        list.add(r);
        list.add(ma);
        return list;
    }
}


C55xShiftOperand Smem_LSHIFT_Tx() :
{
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=Smem() <LSHIFT> r=Tx() {
        return new C55xShiftOperand(ma, true, r); // true: LSHIFT
    }
}

C55xShiftOperand RND_Smem_LSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    <RND> <LPAREN> s=Smem_LSHIFT_Tx() <RPAREN> {
        s.setRndMod();
        return s;
    }
}

C55xShiftOperand rnd_Smem_LSHIFT_Tx() :
{
    C55xShiftOperand s;
}
{
    (s=Smem_LSHIFT_Tx() | s=RND_Smem_LSHIFT_Tx()) {
        return s;
    }
}

List<Operand> rnd_Smem_LSHIFT_Tx_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xShiftOperand s;
    C55xRegisterOperand r;
}
{
    s=rnd_Smem_LSHIFT_Tx() <COMMA> r=ACx() {
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> unsSmem_CARRY_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xBitOperand b;
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=unsSmem() <COMMA> b=CARRY() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        list.add(ma);
        list.add(b);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> unsSmem_BORROW_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xBitOperand b;
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=unsSmem() <COMMA> b=BORROW() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        list.add(ma);
        list.add(b);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

List<Operand> unsSmem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
}
{
    ma=unsSmem() <COMMA> r=ACx() {
        list.add(ma);
        list.add(r);
        return list;
    }
}

List<Operand> unsSmem_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r1, r2 = null;
}
{
    ma=unsSmem() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        list.add(ma);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}

// [uns(]Smem[)] << #SHIFTW, ACx
List<Operand> unsSmem_LSHIFT_SHIFTW_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm;
    C55xRegisterOperand r;
    C55xShiftOperand s;
}
{
    ma=unsSmem() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> r=ACx() {
        s = new C55xShiftOperand(ma, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}

// [uns(]Smem[)] << #SHIFTW, [ACx,] ACy
List<Operand> unsSmem_LSHIFT_SHIFTW_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand ma;
    C55xImmediateOperand imm;
    C55xRegisterOperand r1, r2 = null;
    C55xShiftOperand s;
}
{
    ma=unsSmem() <LSHIFT> <HASH> imm=SHIFTW() <COMMA> r1=ACxy() (<COMMA> r2=ACxy()) ? {
        s = new C55xShiftOperand(ma, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r1);
        if (r2 != null) {
            list.add(r2);
        }
        return list;
    }
}


List<Operand> Xmem_Ymem_ACx() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x, y;
    C55xRegisterOperand r;
}
{
    x=Xmem() <COMMA> y=Ymem() <COMMA> r=ACx() {
        list.add(x);
        list.add(y);
        list.add(r);
        return list;
    }
}

List<Operand> Tx_OPTACx_ACy() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r1, r2, r3 = null;
}
{
    r1=Tx() <COMMA> r2=ACx() (<COMMA> r3=ACy())? {
        list.add(r1);
        list.add(r2);
        if (r3 != null) {
            list.add(r3);
        }
        return list;
    }
}

C55xRegisterOperand AC0() : { Token t; } { t=<AC0> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AC1() : { Token t; } { t=<AC1> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AC2() : { Token t; } { t=<AC2> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AC3() : { Token t; } { t=<AC3> { return new C55xRegisterOperand(t.image); } }

C55xRegisterOperand AR0() : { Token t; } { t=<AR0> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR1() : { Token t; } { t=<AR1> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR2() : { Token t; } { t=<AR2> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR3() : { Token t; } { t=<AR3> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR4() : { Token t; } { t=<AR4> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR5() : { Token t; } { t=<AR5> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR6() : { Token t; } { t=<AR6> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand AR7() : { Token t; } { t=<AR7> { return new C55xRegisterOperand(t.image); } }

C55xRegisterOperand T0()  : { Token t; } { t=<T0>  { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand T0B() : { Token t; } { t=<T0B> { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand T1()  : { Token t; } { t=<T1>  { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand T2()  : { Token t; } { t=<T2>  { return new C55xRegisterOperand(t.image); } }
C55xRegisterOperand T3()  : { Token t; } { t=<T3>  { return new C55xRegisterOperand(t.image); } }

// MISRG p.633
List<Operand> SwapOps() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r, s;
}
{
    (r=AC0() <COMMA> s=AC2()
     | r=AC1() <COMMA> s=AC3()
     | LOOKAHEAD(3)
     r=AR0() <COMMA> s=AR1()
     | r=AR0() <COMMA> s=AR2()
     | r=AR1() <COMMA> s=AR3()
     | r=AR4() <COMMA> s=T0()
     | r=AR5() <COMMA> s=T1()
     | r=AR6() <COMMA> s=T2()
     | r=AR7() <COMMA> s=T3()
     | r=T0()  <COMMA> s=T2()
     | r=T1()  <COMMA> s=T3()) {
        list.add(r);
        list.add(s);
        return list;
    }
}

C55xRegisterOperand PAIR_AC0() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AC0() <RPAREN> { r.setPairMod(); return r; } }
C55xRegisterOperand PAIR_AC2() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AC2() <RPAREN> { r.setPairMod(); return r; } }

C55xRegisterOperand PAIR_AR0() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AR0() <RPAREN> { r.setPairMod(); return r; } }
C55xRegisterOperand PAIR_AR2() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AR2() <RPAREN> { r.setPairMod(); return r; } }
C55xRegisterOperand PAIR_AR4() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AR4() <RPAREN> { r.setPairMod(); return r; } }
C55xRegisterOperand PAIR_AR6() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=AR6() <RPAREN> { r.setPairMod(); return r; } }

C55xRegisterOperand PAIR_T0() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=T0() <RPAREN> { r.setPairMod(); return r; } }
C55xRegisterOperand PAIR_T2() : { C55xRegisterOperand r; }
{ <PAIR> <LPAREN> r=T2() <RPAREN> { r.setPairMod(); return r; } }

List<Operand> SwappOps() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r, s;
}
{
    (LOOKAHEAD(PAIR_AC0())
     r=PAIR_AC0() <COMMA> s=PAIR_AC2()

     |LOOKAHEAD(PAIR_AR0())
     r=PAIR_AR0() <COMMA> s=PAIR_AR2()

     |LOOKAHEAD(PAIR_AR4())
     r=PAIR_AR4() <COMMA> s=PAIR_T0()

     |LOOKAHEAD(PAIR_AR6())
     r=PAIR_AR6() <COMMA> s=PAIR_T2()

     |r=PAIR_T0()  <COMMA> s=PAIR_T2()) {
        list.add(r);
        list.add(s);
        return list;
    }
}

C55xRegisterOperand BLOCK_AR4() : { C55xRegisterOperand r; }
{ <BLOCK> <LPAREN> r=AR4() <RPAREN> { r.setBlockMod(); return r; } }
C55xRegisterOperand BLOCK_T0() : { C55xRegisterOperand r; }
{ <BLOCK> <LPAREN> r=T0() <RPAREN> { r.setBlockMod(); return r; } }

List<Operand> Swap4Ops() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r, s;
}
{
    r=BLOCK_AR4() <COMMA> s=BLOCK_T0() {
        list.add(r);
        list.add(s);
        return list;
    }
}




//////////////////////////////////////////////////////////////////////
//
// IMPLIED PARALLELISM
//
//////////////////////////////////////////////////////////////////////

// XCA16 = Xmem, Cmem, Accumulator, shift by 16
List<Operand> P_XCA16() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand xma, cma;
    C55xRegisterOperand r;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    xma=unsXmem() <COMMA> cma=unsCmem() <COMMA> r=ACx() <RSHIFT> imm=Literal() {
        list.add(xma);
        list.add(cma);
        s = new C55xShiftOperand(r, false, imm); // false: RSHIFT
        list.add(s);
        return list;
    }
}

List<Operand> P_YCA16() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand yma, cma;
    C55xRegisterOperand r;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    yma=unsYmem() <COMMA> cma=unsCmem() <COMMA> r=ACy() <RSHIFT> imm=Literal() {
        list.add(yma);
        list.add(cma);
        s = new C55xShiftOperand(r, false, imm); // false: RSHIFT
        list.add(s);
        return list;
    }
}

List<Operand> P_XCA() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand xma, cma;
    C55xRegisterOperand r;
}
{
    xma=unsXmem() <COMMA> cma=unsCmem() <COMMA> r=ACx()  {
        list.add(xma);
        list.add(cma);
        list.add(r);
        return list;
    }
}

List<Operand> P_YCA() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand yma, cma;
    C55xRegisterOperand r;
}
{
    yma=unsYmem() <COMMA> cma=unsCmem() <COMMA> r=ACy()  {
        list.add(yma);
        list.add(cma);
        list.add(r);
        return list;
    }
}

List<Operand> P_HASTY() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xRegisterOperand r, t2;
    C55xShiftOperand s;
    C55xMemoryAccessOperand yma;
}
{
    <HI> <LPAREN> r=ACx() <LSHIFT> t2=T2() <RPAREN>   <COMMA>   yma=Ymem() {
        s = new C55xShiftOperand(r, true, t2); // true: LSHIFT
        s.setHiMod();
        list.add(s);
        list.add(yma);
        return list;
    }
}

List<Operand> P_OXTA() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x;
    C55xRegisterOperand r1, r2;
}
{
    x=OPTT3EQ_Xmem() <COMMA> r1=Tx() <COMMA> r2=ACx() { //(<COMMA> ACx())?  ignore last part, only a hack for unpack.asm 
        list.add(x);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> P_XS16AA() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x;
    C55xRegisterOperand r1, r2;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    x=Xmem() <LSHIFT> imm=Literal() <COMMA> r1=ACx() <COMMA> r2=ACy() {
        s = new C55xShiftOperand(x, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r1);
        list.add(r2);
        return list;
    }
}

List<Operand> P_XS16A() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand x;
    C55xRegisterOperand r;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    x=Xmem() <LSHIFT> imm=Literal() <COMMA> r=ACx() {
        s = new C55xShiftOperand(x, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}

List<Operand> P_YS16A() :
{
    List<Operand> list = new ArrayList<Operand>();
    C55xMemoryAccessOperand y;
    C55xRegisterOperand r;
    C55xImmediateOperand imm; // 16
    C55xShiftOperand s;
}
{
    y=Ymem() <LSHIFT> imm=Literal() <COMMA> r=ACy() {
        s = new C55xShiftOperand(y, true, imm); // true: LSHIFT
        list.add(s);
        list.add(r);
        return list;
    }
}



// Xmem << #16, ACx, ACy
// :: mov HI(ACy << T2), Ymem
List P_XS16AA_MOV_HASTY() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XS16AA() <DOUBLE_COLONS> t=<MOV> l2=P_HASTY() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. add::mov


List P_HASTY_ADD_XS16AA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<ADD> l2=P_XS16AA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mov::add


// Xmem
// :: mac[r][40] [uns(]Ymem[)], [uns(]Cmem[)], ACx
List P_Xmem_MAC_YCA() :
{
    List list = new ArrayList(), l1 = new ArrayList(), l2;
    C55xMemoryAccessOperand ma;
    Token t;
}
{
    ma=Xmem() <DOUBLE_COLONS> t=<MAC> l2=P_YCA() {
        l1.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. amar::mac


List P_YCA_AMAR_Xmem() :
{
    List list = new ArrayList(), l1, l2 = new ArrayList();
    C55xMemoryAccessOperand ma;
    Token t;
}
{ 
    l1=P_YCA() <DOUBLE_COLONS> t=<AMAR> ma=Xmem() {
        l2.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // ?::amar


// Xmem
// :: mas[r][40] [uns(]Ymem[)], [uns(]Cmem[)], ACx
List P_Xmem_MAS_YCA() :
{
    List list = new ArrayList(), l1 = new ArrayList(), l2;
    C55xMemoryAccessOperand ma;
    Token t;
}
{
    ma=Xmem() <DOUBLE_COLONS> t=<MAS> l2=P_YCA() {
        l1.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. amar::mas, mas::amar


// Xmem
// :: mpy[r][40] [uns(]Ymem[)], [uns(]Cmem[)], ACx
List P_Xmem_MPY_YCA() :
{
    List list = new ArrayList(), l1 = new ArrayList(), l2;
    C55xMemoryAccessOperand ma;
    Token t;
}
{
    ma=Xmem() <DOUBLE_COLONS> t=<MPY> l2=P_YCA() {
        l1.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. amar::mpy, mpy::amar


// Xmem
// :: mac [uns(]Ymem[)], [uns(]Cmem[)], AC >> #16"
List P_Xmem_MAC_YCA16() :
{
    List list = new ArrayList(), l1 = new ArrayList(), l2;
    C55xMemoryAccessOperand ma;
    Token t;
}
{
    ma=Xmem() <DOUBLE_COLONS> t=<MAC> l2=P_YCA16() {
        l1.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. amar::mac


List P_YCA16_AMAR_Xmem()  :
{
    List list = new ArrayList(), l1, l2 = new ArrayList();
    C55xMemoryAccessOperand ma;
    Token t;
}
{ 
    l1=P_YCA16() <DOUBLE_COLONS> t=<AMAR> ma=Xmem() {
        l2.add(ma);

        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}    // e.g. mac::amar


// [uns(]Xmem[)], [uns(]Cmem[)], ACx
// :: MAC[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy
// [uns(]Xmem[)], [uns(]Cmem[)], ACx
// :: MAS[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy
// [uns(]Xmem[)], [uns(]Cmem[)], ACx
// :: MPY[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy
List P_XCA_MAC_YCA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XCA() <DOUBLE_COLONS> t=<MAC> l2=P_YCA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}   // e.g. mac::mac, mas::mac, mpy::mac


List P_XCA_MAS_YCA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XCA() <DOUBLE_COLONS> t=<MAS> l2=P_YCA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}   // e.g. mac::mas, mas::mas, mpy::mas


List P_XCA_MPY_YCA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XCA() <DOUBLE_COLONS> t=<MPY> l2=P_YCA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}   // e.g. mac::mpy, mas::mpy, mpy::mpy


// [uns(]Xmem[)], [uns(]Cmem[)], ACx >> #16
// :: MAC[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy
List P_XCA16_MAC_YCA() :
{
    List list = new ArrayList<Operand>(), l1, l2;
    Token t;
}
{
    l1=P_XCA16() <DOUBLE_COLONS> t=<MAC> l2=P_YCA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}   // e.g. mac::mac


// [uns(]Xmem[)], [uns(]Cmem[)], ACx >> #16
// :: MAC[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy >> #16
List P_XCA16_MAC_YCA16() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XCA16() <DOUBLE_COLONS> t=<MAC> l2=P_YCA16() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mac::mac


// [uns(]Xmem[)], [uns(]Cmem[)], ACx
// :: MAC[R][40] [uns(]Ymem[)], [uns(]Cmem[)], ACy >> #16
List P_XCA_MAC_YCA16() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XCA() <DOUBLE_COLONS> t=<MAC> l2=P_YCA16() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mac::mac, mas::mac, mpy::mac


// [T3 = ]Xmem, Tx, ACx
// :: MOV Ymem << #16, ACy
List<Operand> P_OXTA_MOV_YS16A() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_OXTA()        <DOUBLE_COLONS> t=<MOV> l2=P_YS16A() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. macm::mov, masm::mov


List<Operand> P_YS16A_MACM_OXTA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_YS16A() <DOUBLE_COLONS> t=<MACM> l2=P_OXTA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mov::macm


List<Operand> P_YS16A_MASM_OXTA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_YS16A() <DOUBLE_COLONS> t=<MASM> l2=P_OXTA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mov::masm


// [T3 = ]Xmem, Tx, ACy
// :: MOV HI(ACx << T2), Ymem
List<Operand> P_OXTA_MOV_HASTY() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_OXTA()        <DOUBLE_COLONS> t=<MOV> l2=P_HASTY() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. macm::mov, masm::mov, mpym::mov


List<Operand> P_HASTY_MACM_OXTA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<MACM> l2=P_OXTA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mov::macm


List<Operand> P_HASTY_MASM_OXTA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<MASM> l2=P_OXTA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mov::masm


List<Operand> P_HASTY_MPYM_OXTA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<MPYM> l2=P_OXTA() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mov::mpym


// Xmem << #16, ACy
// :: MOV HI(ACx << T2), Ymem
List<Operand> P_XS16A_MOV_HASTY() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_XS16A() <DOUBLE_COLONS> t=<MOV> l2=P_HASTY() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mov::mov, sub::mov


List<Operand> P_HASTY_MOV_XS16A() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<MOV> l2=P_XS16A() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mov::mov


List<Operand> P_HASTY_SUB_XS16A() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=P_HASTY() <DOUBLE_COLONS> t=<SUB> l2=P_XS16A() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. mov::sub


// ACx, ACy
// :: NEXP ACx, Tx
List<Operand> P_AA_NEXP_AT() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=ACx_ACy() <DOUBLE_COLONS> t=<NEXP> l2=ACx_Tx() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
}  // e.g. mant::nexp


List P_AT_MANT_AA() :
{
    List list = new ArrayList(), l1, l2;
    Token t;
}
{
    l1=ACx_Tx() <DOUBLE_COLONS> t=<MANT> l2=ACx_ACy() {
        list.add(l1);
        list.add(t.image);
        list.add(l2);
        return list;
    }
} // e.g. nexp::mant


//////////////////////////////////////////////////////////////////////
//
// IMPLIED PARALLELISM END
//
//////////////////////////////////////////////////////////////////////



//
// page numbers are from MISRG (SPRU374G), unless stated otherwise
//
C55xOperation Oper() :
{
    C55xOperation op = null;
    Token t = null, t2 = null;
    List<Operand> args = new ArrayList<Operand>();
    C55xBitOperand b;
    C55xConditionFieldOperand cf;
    C55xImmediateOperand imm;
    C55xMemoryAccessOperand ma;
    C55xRegisterOperand r;
    C55xProgramAddressOperand target;
}
{
    t=<AADD> (
              args = TAx_TAy() {
                  return m.make_AADD_p95_Instr(t.image, args, "aadd TAx, TAy");
              } // p.95
              | LOOKAHEAD(P8_TAx())  
              args = P8_TAx() {
                  return m.make_AADD_p97_Instr(t.image, args, "aadd P8, TAx"); 
              } // p.97
              | args = K8_SP() {
                  return m.make_AADD_p98_Instr(t.image, args, "aadd K8, SP"); 
              } // p.98
              ) { Main.fatal("aadd error"); }


    | t=<ABDST> (
                 args = Xmem_Ymem_ACx_ACy() {
                     return m.make_ABDST_p99_Instr(t.image, args, "abdst Xmem, Ymem, ACx, ACy"); 
                 } // p.99
               ) { Main.fatal("abdst error"); }


    | t=<ABS> (
               args = OPTsrc_dst() {
                   return m.make_ABS_p101_Instr(t.image, args, "abs [src,] dst"); 
               } // p.101
               ) { Main.fatal("abs error"); }


    | t=<ADD> (
               LOOKAHEAD(P_XS16AA_MOV_HASTY())
               args = P_XS16AA_MOV_HASTY() {
                   return m.make_ADD_p130_Instr(t.image, args, "add Xmem << #16, ACx, ACy :: mov HI(ACy << T2), Ymem"); 
               } // p.130 add::mov

               |LOOKAHEAD(k4K16_OPTsrc_dst())
               args = k4K16_OPTsrc_dst() {
                   return m.make_ADD_p107_Instr(t.image, args, "add k4|K16, [src,], dst"); 
               } // p.107,8

               | LOOKAHEAD(Smem_OPTsrc_dst())
               args = Smem_OPTsrc_dst() {
                   return m.make_ADD_p110_Instr(t.image, args, "add Smem, [src,], dst"); 
               } // p.110

               | LOOKAHEAD(ACx_LSHIFT_Tx_ACy())
               args = ACx_LSHIFT_Tx_ACy() {
                   return m.make_ADD_p112_Instr(t.image, args, "add ACx << Tx, ACy"); 
               } // p.112

               | LOOKAHEAD(ACx_LSHIFT_SHIFTW_ACy())
               args = ACx_LSHIFT_SHIFTW_ACy() {
                   return m.make_ADD_p113_Instr(t.image, args, "add ACx << #SHIFTW, ACy"); 
               } // p.113

               | LOOKAHEAD(K16_LSHIFT_16_OPTACx_ACy())
               args = K16_LSHIFT_16_OPTACx_ACy() {
                   return m.make_ADD_p114_Instr(t.image, args, "add K16 << #16, [ACx,], ACy");
               } // p.114

               | LOOKAHEAD(K16_LSHIFT_SHFT_OPTACx_ACy())
               args = K16_LSHIFT_SHFT_OPTACx_ACy() {
                   return m.make_ADD_p115_Instr(t.image, args, "add K16 << #SHFT, [ACx,], ACy");
               } // p.115

               | LOOKAHEAD(Smem_LSHIFT_Tx_OPTACx_ACy())
               args = Smem_LSHIFT_Tx_OPTACx_ACy() {
                   return m.make_ADD_p116_Instr(t.image, args, "add Smem << Tx, [ACx,], ACy");
               } // p.116

               /*| LOOKAHEAD(Smem_LSHIFT_16_OPTACx_ACy())
               args = Smem_LSHIFT_16_OPTACx_ACy() {
                   return m.make_ADD_p118_Instr(t.image, args, "add Smem << #16, [ACx,], ACy");
                   } // p.118 */

               | LOOKAHEAD(unsSmem_CARRY_OPTACx_ACy())
               args = unsSmem_CARRY_OPTACx_ACy() {
                   return m.make_ADD_p119_Instr(t.image, args, "add [uns(]Smem[)], CARRY, [ACx,] ACy"); 
               } // p.119

               | LOOKAHEAD(unsSmem_OPTACx_ACy())
               args = unsSmem_OPTACx_ACy()  {
                   return m.make_ADD_p120_Instr(t.image, args, "add [uns(]Smem[)], [ACx,] ACy"); 
               } // p.120

               | LOOKAHEAD(unsSmem_LSHIFT_SHIFTW_OPTACx_ACy())
               args = unsSmem_LSHIFT_SHIFTW_OPTACx_ACy() {
                   return m.make_ADD_p121_Instr(t.image, args, "add [uns(]Smem[)] << #SHIFTW, [ACx,] ACy"); 
               } // p.121

               | args = DBL_Lmem_OPTACx_ACy() {
                   return m.make_ADD_p122_Instr(t.image, args, "add dbl(Lmem), [ACx,] ACy"); 
               } // p.122

               | LOOKAHEAD(Xmem_Ymem_ACx())
               args = Xmem_Ymem_ACx() {
                   return m.make_ADD_p123_Instr(t.image, args, "add Xmem, Ymem, ACx"); 
               } // p.123

               | args = K16_Smem() {
                   return m.make_ADD_p124_Instr(t.image, args, "add K16, Smem"); 
               } // p.124

               | LOOKAHEAD(DUAL_Lmem_Tx_ACx())
               args = DUAL_Lmem_Tx_ACx() {
                   return m.make_ADD_p128_Instr(t.image, args, "add dual(Lmem), Tx, ACx"); 
               } // p.128

               | args = DUAL_Lmem_OPTACx_ACy() {
                   return m.make_ADD_p126_Instr(t.image, args, "add dual(Lmem), [ACx,] ACy"); 
               } // p.126

               | LOOKAHEAD(OPTsrc_dst())
               args = OPTsrc_dst() {
                   return m.make_ADD_p106_Instr(t.image, args, "add [src,] dst"); 
               } // p.106
               ) { Main.fatal("add error"); }


    | t=<ADDSUB> (
                  LOOKAHEAD(Tx_Smem_ACx())
                  args = Tx_Smem_ACx() {
                      return m.make_ADDSUB_p133_Instr(t.image, args, "addsub Tx, Smem, ACx"); 
                  } // p.133

                  |LOOKAHEAD(Tx_DUAL_Lmem_ACx())
                  args = Tx_DUAL_Lmem_ACx() {
                      return m.make_ADDSUB_p135_Instr(t.image, args, "addsub Tx, dual(Lmem), ACx"); 
                  } // p.135

                  |args = DUAL_Lmem_Tx_ACx() { // for some reason disassmbler changes order of Tx and dual(Lmem) of p135 instr.
                      return m.make_ADDSUB_p135_Instr(t.image, args, "addsub dual(Lmem), Tx, ACx"); 
                  } // p.135
                  ) { Main.fatal("addsub error"); }


    | t=<ADDSUBCC> (
                    LOOKAHEAD(Smem_ACx_TCx_ACy())
                    args = Smem_ACx_TCx_ACy() {
                        return m.make_ADDSUBCC_p137_Instr(t.image, args, "addsubcc Smem, ACx, TCx, ACy"); 
                    } // p.137

                    | args = Smem_ACx_TC1_TC2_ACy() {
                        return m.make_ADDSUBCC_p139_Instr(t.image, args, "addsubcc Smem, ACx, TC1, TC2, ACy"); 
                    } // p.139
                    ) { Main.fatal("addsubcc error"); }


    | t=<ADDSUB2CC> (
                     args = Smem_ACx_Tx_TC1_TC2_ACy() {
                         return m.make_ADDSUB2CC_p141_Instr(t.image, args, "addsubcc Smem, ACx, Tx, TC1, TC2, ACy"); 
                     } // p.141
                     ) { Main.fatal("addsub2cc error"); }
    

    | t=<ADDV> (
                args = OPTACx_ACy() {
                    return m.make_ADDV_p144_Instr(t.image, args, "addv [ACx,] ACy");
                } // p.144
                ) { Main.fatal("addv error"); }


    | t=<AMAR> (
                LOOKAHEAD(P_Xmem_MAC_YCA16())
                args = P_Xmem_MAC_YCA16() {
                    return m.make_AMAR_p153_Instr(t.image, args, "amar Xmem :: mac [uns(]Ymem[)], [uns(]Cmem[)], ACx >> #16"); 
                } // amar::mac

                |LOOKAHEAD(P_Xmem_MAC_YCA())
                args = P_Xmem_MAC_YCA() {
                    return m.make_AMAR_p151_Instr(t.image, args, "amar Xmem :: mac [uns(]Ymem[)], [uns(]Cmem[)], ACx"); 
                } // amar::mac

                |LOOKAHEAD(P_Xmem_MAS_YCA())
                args = P_Xmem_MAS_YCA() {
                    return m.make_AMAR_p155_Instr(t.image, args, "amar Xmem :: mas [uns(]Ymem[)], [uns(]Cmem[)], ACx"); 
                } // amar::mas

                |LOOKAHEAD(P_Xmem_MPY_YCA())
                args = P_Xmem_MPY_YCA() {
                    return m.make_AMAR_p157_Instr(t.image, args, "amar Xmem :: mpy [uns(]Ymem[)], [uns(]Cmem[)], ACx"); 
                } // amar::mpy

                |LOOKAHEAD(Smem_XAdst())
                args = Smem_XAdst() {
                    return m.make_AMAR_p148_Instr(t.image, args, "amar Smem, XAdst"); 
                } // p.148

                |LOOKAHEAD(Xmem_Ymem_Cmem())
                args = Xmem_Ymem_Cmem() {
                    return m.make_AMAR_p149_Instr(t.image, args, "amar Xmem, Ymem, Cmem"); 
                } // p.149

                | ma = Smem() {
                    args.add(ma);
                    return m.make_AMAR_p146_Instr(t.image, args, "amar Smem"); 
                } // p.146
                ) { Main.fatal("amar error"); }


    | t=<AMOV> (
                LOOKAHEAD(k23_XAdst())
                args = k23_XAdst() {
                    return m.make_AMOV_p159_Instr(t.image, args, "amov k23, XAdst"); 
                } // p.159

                | args = TAx_TAy() {
                    return m.make_AMOV_p161_Instr(t.image, args, "amov TAx, TAy"); 
                } // p.161

                | args = P8D16_TAx() {
                    return m.make_AMOV_p162_Instr(t.image, args, "amov P8|D16, TAx"); 
                } // p.162-3
                ) { Main.fatal("amov error"); }


    | t=<AND> (
               LOOKAHEAD(k8k16_OPTsrc_dst())
               args = k8k16_OPTsrc_dst() {
                   return m.make_AND_p166_Instr(t.image, args, "and k8|k16, src, dst"); 
               } // p.166

               | args =  Smem_OPTsrc_dst() {
                   return m.make_AND_p168_Instr(t.image, args, "and Smem, src, dst"); 
               } // p.168

               | LOOKAHEAD(ACx_LSHIFT_SHIFTW_OPTACy())
               args = ACx_LSHIFT_SHIFTW_OPTACy() {
                   return m.make_AND_p169_Instr(t.image, args, "and ACx << #SHIFTW [,ACy]"); 
               } // p.169

               | LOOKAHEAD(k16_LSHIFT_16_OPTACx_ACy())
               args = k16_LSHIFT_16_OPTACx_ACy() {
                   return m.make_AND_p170_Instr(t.image, args, "and k16 << #16, [ACx,] ACy"); 
               } // p.170

               | LOOKAHEAD(k16_LSHIFT_SHFT_OPTACx_ACy())
               args = k16_LSHIFT_SHFT_OPTACx_ACy() {
                   return m.make_AND_p171_Instr(t.image, args, "and k16 << #SHFT, [ACx,] ACy"); 
               } // p.171

               | args =  k16_Smem() {
                   return m.make_AND_p172_Instr(t.image, args, "and k16, Smem"); 
               } // p.172

               | args =  OPTsrc_dst() {
                   return m.make_AND_p165_Instr(t.image, args, "and src, dst"); 
               } // p.165
               ) { Main.fatal("and error"); }


    | t=<ASUB> (
                args = TAx_TAy() {
                    return m.make_ASUB_p174_Instr(t.image, args, "asub TAx, TAy"); 
                } // p.174
                | args =  P8_TAx() {
                    return m.make_ASUB_p176_Instr(t.image, args, "asub P8, TAx"); 
                } // p.176
                ) { Main.fatal("asub error"); }


    | t=<B> (
             r = ACx() {
                 args.add(r);
                 return m.make_B_p178_Instr(t.image, args, "b ACx"); 
             } // p.178
             | target = Address() {
                 args.add(target);
                 return m.make_B_p179_Instr(t.image, args, "b L7|L16|P24"); 
             }
             ) { Main.fatal("b error"); }


    | t=<BAND> (
                args = Smem_k16_TCx() {
                    return m.make_BAND_p181_Instr(t.image, args, "band Smem, k16, TCx"); 
                } // p.181
                ) { Main.fatal("band error"); }


    | t=<BCC> (
               LOOKAHEAD(Address_cond())
               args = Address_cond() {
                   return m.make_BCC_p182_Instr(t.image, args, "bcc label, cond"); 
               } // p.182-5

               |LOOKAHEAD(L8_src_RELOP_K8())
               args = L8_src_RELOP_K8() {
                   return m.make_BCC_p189_Instr(t.image, args, "bcc L8, src RELOP K8"); 
               } //p.189

               |args = L16_ARn_mod_NE_0() {
                   return m.make_BCC_p186_Instr(t.image, args, "bcc L16, ARn_mod != #0"); 
               } //p.186


               ) { Main.fatal("bcc error"); }


    | t=<BCLR> ( 
                LOOKAHEAD(Baddr_src())
                args = Baddr_src() {
                    return m.make_BCLR_p192_Instr(t.image, args, "bclr Baddr, src"); 
                } // p.192

                | args =  src_Smem() {
                    return m.make_BCLR_p193_Instr(t.image, args, "bclr src, Smem"); 
                } // p.193

                | LOOKAHEAD(k4_STx())
                args = k4_STx() {
                    return m.make_BCLR_p194_No1234_Instr(t.image, args, "bclr k4, STx"); 
                } // p.194

                | b = fname()  {
                    args.add(b);
                    return m.make_BCLR_p194_No5_Instr(t.image, args, "bclr f-name"); 
                } // p.194

                ) { Main.fatal("bclr error"); }


    | t=<BCNT> (
                args = ACx_ACy_TCx_Tx() {
                    return m.make_BCNT_p197_Instr(t.image, args, "bcnt ACx, ACy, TCx, Tx"); 
                } // p.197
                ) { Main.fatal("bcnt error"); }


    | t=<BFXPA> (
                 args = k16_ACx_dst() {
                     return m.make_BFXPA_p198_Instr(t.image, args, "bfxpa k16, ACx, dst"); 
                 } // p.198
                 ) { Main.fatal("bfxpa error"); }


    | t=<BFXTR> (
                 args = k16_ACx_dst() {
                     return m.make_BFXTR_p199_Instr(t.image, args, "bfxtr k16, ACx, dst"); 
                 } // p.199
                 ) { Main.fatal("bfxtr error"); }


    | t=<BNOT> (
                LOOKAHEAD(Baddr_src())
                args = Baddr_src() {
                    return m.make_BNOT_p200_Instr(t.image, args, "bnot Baddr, src"); 
                } // p.200
                | args =  src_Smem() {
                    return m.make_BNOT_p201_Instr(t.image, args, "bnot src, Smem"); 
                } // p.201
                ) { Main.fatal("bnot error"); }


    | t=<BSET> (
              LOOKAHEAD(Baddr_src())
              args = Baddr_src() {
                  return m.make_BSET_p202_Instr(t.image, args, "bset Baddr, src"); 
              } // p.202

              | args =  src_Smem() {
                  return m.make_BSET_p203_Instr(t.image, args, "bset src, Smem"); 
              } // p.203

              |LOOKAHEAD(k4_STx())
              args = k4_STx() {
                  return m.make_BSET_p204_No1234_Instr(t.image, args, "bset k4, STx"); 
              } // p.204

              | b = fname()  {
                  args.add(b);
                  return m.make_BSET_p204_No5_Instr(t.image, args, "bset f-name"); 
              } // p.204
              )


    | t=<BTST> (
                LOOKAHEAD(Baddr_src_TCx())
                args = Baddr_src_TCx() {
                    return m.make_BTST_p207_Instr(t.image, args, "btst Baddr, src, TCx"); 
                } // p.207

                | args =  src_Smem_TCx()  {
                    return m.make_BTST_p210_Instr(t.image, args, "btst src, Smem, TCx"); 
                } // p.210

                | args =  k4_Smem_TCx()  {
                    return m.make_BTST_p211_Instr(t.image, args, "btst k4, Smem, TCx"); 
                } // p.211

                ) { Main.fatal("btst error"); }


    | t=<BTSTCLR> (
                   args = k4_Smem_TCx()  {
                       return m.make_BTSTCLR_p212_Instr(t.image, args, "btstclr k4, Smem, TCx"); 
                   } // p.212
                ) { Main.fatal("btstclr error"); }


    | t=<BTSTNOT> (
                   args = k4_Smem_TCx()  {
                       return m.make_BTSTNOT_p213_Instr(t.image, args, "btstclr k4, Smem, TCx"); 
                   } // p.213
                ) { Main.fatal("btstnot error"); }


    | t=<BTSTP> (
                 args = Baddr_src() {
                     return m.make_BTSTP_p214_Instr(t.image, args, "btstp Baddr, src"); 
                 } // p.214
                ) { Main.fatal("btstp error"); }


    | t=<BTSTSET> (
                   args = k4_Smem_TCx() {
                       return m.make_BTSTSET_p216_Instr(t.image, args, "btstset k4, Smem, TCx"); 
                   } // p.216
                ) { Main.fatal("btstset error"); }


    | t=<CALL> (
                r = ACx() {
                    args.add(r);
                    return m.make_CALL_p218_Instr(t.image, args, "call ACx"); 
                } // p.218

                | target = Address() {
                    args.add(target);
                    return m.make_CALL_p219_Instr(t.image, args, "call label"); 
                } // p.219-20
                ) { Main.fatal("call error"); }


    | t=<CALLCC> (
                  args = Address_cond() {
                      return m.make_CALLCC_p223_Instr(t.image, args, "callcc label, cond"); 
                  } // p.223
                ) { Main.fatal("callcc error"); }


    | t=<CMP> (
               LOOKAHEAD(Smem_EQ_K16_TCx())
               args = Smem_EQ_K16_TCx() {
                   return m.make_CMP_p227_Instr(t.image, args, "cmp Smem == K16, TCx"); 
               } // p.227

               | args = src_RELOP_dst_TCx() {
                   return m.make_CMP_p229_Instr(t.image, args, "cmp src RELOP dst, TCx"); 
               } // p.229
                ) { Main.fatal("cmp error"); }


    | t=<CMPU> (
                args = src_RELOP_dst_TCx() {
                    return m.make_CMPU_p229_Instr(t.image, args, "cmpu src RELOP dst, TCx"); 
                } // p.229
                ) { Main.fatal("cmpu error"); }


    | t=<CMPAND> (
                  args = src_RELOP_dst_OPTBANG_TCy_TCx() {
                      return m.make_CMPAND_p231_Instr(t.image, args, "cmpand src RELOP dst, [!]TCy, TCx"); 
                  } // p.231
                  ) { Main.fatal("cmpand error"); }


    | t=<CMPOR> (
                 args = src_RELOP_dst_OPTBANG_TCy_TCx() {
                     return m.make_CMPOR_p236_Instr(t.image, args, "cmpor src RELOP dst, [!]TCy, TCx"); 
                 } // p.236
                  ) { Main.fatal("cmpor error"); }


    | t=<DELAY> (
                 ma = Smem() {
                     args.add(ma);
                     return m.make_DELAY_p242_Instr(t.image, args, "delay Smem"); 
                 } // p.242
                 ) { Main.fatal("delay error"); }


    | t=<EXP> (
               args = ACx_Tx() {
                   return m.make_EXP_p243_Instr(t.image, args, "exp ACx, Tx"); 
               } // p.243
                 ) { Main.fatal("exp error"); }


    | t=<FIRSADD> (
                   args = Xmem_Ymem_Cmem_ACx_ACy() {
                       return m.make_FIRSADD_p244_Instr(t.image, args, "firsadd Xmem, Ymem, Cmem, ACx, ACy"); 
                   } // p.244
                   ) { Main.fatal("firsadd error"); }

    | t=<FIRSSUB> (
                   args = Xmem_Ymem_Cmem_ACx_ACy() {
                       return m.make_FIRSSUB_p246_Instr(t.image, args, "firssub Xmem, Ymem, Cmem, ACx, ACy"); 
                   } // p.246
                   ) { Main.fatal("firssub error"); }

    | t=<IDLE> {
        return m.make_IDLE_p248_Instr(t.image, args, "idle"); 
    } // p.248


    | t=<INTR> (
                imm = k5() {
                    args.add(imm);
                    return m.make_INTR_p249_Instr(t.image, args, "intr k5"); 
                } // p.249
                ) { Main.fatal("intr error"); }


    | t=<LMS> (
               args = Xmem_Ymem_ACx_ACy() {
                   return m.make_LMS_p251_Instr(t.image, args, "lms Xmem, Ymem, ACx, ACy"); 
               } // p.251
               ) { Main.fatal("lms error"); }


    | t=<MAC> (
               LOOKAHEAD(P_XCA16_MAC_YCA16())
               args = P_XCA16_MAC_YCA16() {
                   return m.make_MAC_p276_Instr(t.image, args, "mac :: XCA16_MAC_YCA16"); 
               } // mac::mac

               |LOOKAHEAD(P_YCA16_AMAR_Xmem())
               args = P_YCA16_AMAR_Xmem() {
                   return m.make_AMAR_p153_Instr(t.image, args, "mac :: YCA16_AMAR_Xmem"); 
               } // amar::mac reverse

               |LOOKAHEAD(P_XCA16_MAC_YCA())
               args = P_XCA16_MAC_YCA() {
                   return m.make_MAC_p274_Instr(t.image, args, "mac :: XCA16_MAC_YCA"); 
               } // mac::mac

               |LOOKAHEAD(P_XCA_MAC_YCA16())
               args = P_XCA_MAC_YCA16() {
                   return m.make_MAC_p274_Instr(t.image, args, "mac :: XCA_MAC_YCA16"); 
               } // mac::mac reverse

               |LOOKAHEAD(P_YCA_AMAR_Xmem())
               args = P_YCA_AMAR_Xmem() {
                   return m.make_AMAR_p151_Instr(t.image, args, "mac :: YCA_AMAR_Xmem"); 
               } // amar::mac reverse

               |LOOKAHEAD(P_XCA_MAC_YCA())
               args = P_XCA_MAC_YCA() {
                   return m.make_MAC_p272_Instr(t.image, args, "mac :: XCA_MAC_YCA"); 
               } // mac::mac

               |LOOKAHEAD(P_XCA_MAS_YCA())
               args = P_XCA_MAS_YCA() {
                   return m.make_MAS_p297_Instr(t.image, args, "mac :: XCA_MAS_YCA"); 
               } // mas::mac reverse

               |LOOKAHEAD(P_XCA_MPY_YCA())
               args = P_XCA_MPY_YCA() {
                   return m.make_MAC_p278_Instr(t.image, args, "mac :: XCA_MPY_YCA"); 
               } // mac::mpy

               |LOOKAHEAD(7)
               args = ACxy_Tx_ACyx_ACy() {
                   return m.make_MAC_p257_Instr(t.image, args, "mac ACxy, Tx, ACyx, ACy"); 
               } // p.257

               | args = ACx_Tx_ACy() {
                   return m.make_MAC_p256_Instr(t.image, args, "mac ACx, Tx, ACy"); 
               } // p.256
               ) { Main.fatal("mac error"); }


    | t=<MACK> (
                args = Tx_K8K16_OPTACx_ACy() {
                    return m.make_MACK_p258_Instr(t.image, args, "mack Tx, Kx, [ACx,] ACy"); 
                } // p.258, 259
                ) { Main.fatal("mack error"); }


    | t=<MACM> (LOOKAHEAD(P_OXTA_MOV_YS16A())
                args = P_OXTA_MOV_YS16A() {
                    return m.make_MACM_p281_Instr(t.image, args, "macm :: OXTA_MOV_YS16A"); 
                } // macm::mov

                |LOOKAHEAD(P_OXTA_MOV_HASTY())
                args = P_OXTA_MOV_HASTY() {
                    return m.make_MACM_p283_Instr(t.image, args, "macm :: OXTA_MOV_HASTY"); 
                } // macm::mov

                |LOOKAHEAD(OPTT3EQ_unsXmem_unsYmem_ACx_RSHIFT_16_OPTACy())
                args = OPTT3EQ_unsXmem_unsYmem_ACx_RSHIFT_16_OPTACy() {
                    return m.make_MACM_p267_Instr(t.image, args, "macm[r][40] [T3 = ][uns(]Xmem[)], [uns(]Ymem[)], ACx >> #16[, ACy]"); 
                } // p.267

                |LOOKAHEAD(OPTT3EQ_Smem_Cmem_ACx())
                args = OPTT3EQ_Smem_Cmem_ACx() {
                    return m.make_MACM_p260_Instr(t.image, args, "macm [T3 =]Smem, Cmem, ACx"); 
                } // p.260

                |LOOKAHEAD(OPTT3EQ_Smem_OPTACx_ACy())
                args = OPTT3EQ_Smem_OPTACx_ACy() {
                    return m.make_MACM_p262_Instr(t.image, args, "macm [T3 =]Smem, [ACx,] ACy"); 
                } // p.262

                |LOOKAHEAD(OPTT3EQ_Smem_Tx_OPTACx_ACy())
                args = OPTT3EQ_Smem_Tx_OPTACx_ACy() {
                    return m.make_MACM_p263_Instr(t.image, args, "macm [T3 =]Smem, Tx, [ACx,] ACy"); 
                } // p.263

                |LOOKAHEAD(OPTT3EQ_unsXmem_unsYmem_OPTACx_ACy())
                args = OPTT3EQ_unsXmem_unsYmem_OPTACx_ACy() {                   
                    return m.make_MACM_p265_Instr(t.image, args, "macm[r][40] [T3 = ][uns(]Xmem[)], [uns(]Ymem[)], [ACx,] ACy"); 
                } // p.265
                ) { Main.fatal("macm error"); }


    | t=<MACMK> (
                 args = OPTT3EQ_Smem_K8_OPTACx_ACy() {
                     return m.make_MACMK_p264_Instr(t.image, args, "macmk [T3 = ]Smem, K8, [ACx,] ACy"); 
                 } // p.264
                 ) { Main.fatal("macmk error"); }


    | t=<MACMZ> (
                 args = OPTT3EQ_Smem_Cmem_ACx() {
                     return m.make_MACMZ_p269_Instr(t.image, args, "macmz [T3 = ]Smem, Cmem, ACx"); 
                 } // p.269
                 ) { Main.fatal("macmz error"); }


    | t=<MANT> (
                args = P_AA_NEXP_AT() {
                    return m.make_MANT_p285_Instr(t.image, args, "mant::nexp"); 
                } // p.285 mant::nexp
                ) { Main.fatal("mant error"); }


    | t=<MAS> (
               LOOKAHEAD(P_YCA_AMAR_Xmem())
               args = P_YCA_AMAR_Xmem() {
                   return m.make_AMAR_p155_Instr(t.image, args, "mas:: YCA_AMAR_Xmem"); 
               } // amar::mas reverse

               |LOOKAHEAD(P_XCA_MAC_YCA16())
               args = P_XCA_MAC_YCA16() {
                   return m.make_MAS_p299_Instr(t.image, args, "mas:: XCA_MAC_YCA16"); 
               } // mas::mac

               |LOOKAHEAD(P_XCA_MAC_YCA())
               args = P_XCA_MAC_YCA() {
                   return m.make_MAS_p297_Instr(t.image, args, "mas:: XCA_MAC_YCA"); 
               } // mas::mac

               |LOOKAHEAD(P_XCA_MAS_YCA())
               args = P_XCA_MAS_YCA() {
                   return m.make_MAS_p301_Instr(t.image, args, "mas:: XCA_MAS_YCA"); 
               } // mas::mas

               |LOOKAHEAD(P_XCA_MPY_YCA())
               args = P_XCA_MPY_YCA() {
                   return m.make_MAS_p304_Instr(t.image, args, "mas:: XCA_MPY_YCA"); 
               } // mas::mpy

               | args = Tx_OPTACx_ACy() {
                   return m.make_MAS_p288_Instr(t.image, args, "mas Tx, [ACx,] ACy"); 
               } // p.288
               ) { Main.fatal("mas error"); }


    | t=<MASM> (
                LOOKAHEAD(P_OXTA_MOV_YS16A())
                args = P_OXTA_MOV_YS16A() {
                    return m.make_MASM_p307_Instr(t.image, args, "masm :: OXTA_MOV_YS16A"); 
                } // masm::mov

                |LOOKAHEAD(P_OXTA_MOV_HASTY())
                args = P_OXTA_MOV_HASTY()  {
                    return m.make_MASM_p309_Instr(t.image, args, "masm :: OXTA_MOV_HASTY"); 
                } // masm::mov

                |LOOKAHEAD(OPTT3EQ_Smem_Cmem_ACx())
                args = OPTT3EQ_Smem_Cmem_ACx() {
                    return m.make_MASM_p290_Instr(t.image, args, "masm [T3 =]Smem, Cmem, ACx"); 
                } // p.290

                |LOOKAHEAD(OPTT3EQ_Smem_OPTACx_ACy())
                args = OPTT3EQ_Smem_OPTACx_ACy() {
                    return m.make_MASM_p292_Instr(t.image, args, "masm [T3 =]Smem, [ACx,] ACy"); 
                } // p.292

                |LOOKAHEAD(OPTT3EQ_Smem_Tx_OPTACx_ACy())
                args = OPTT3EQ_Smem_Tx_OPTACx_ACy() {
                    return m.make_MASM_p293_Instr(t.image, args, "masm [T3 =]Smem, Tx, [ACx,] ACy"); 
                } // p.293

                |LOOKAHEAD(OPTT3EQ_unsXmem_unsYmem_OPTACx_ACy())
                args = OPTT3EQ_unsXmem_unsYmem_OPTACx_ACy() {
                    return m.make_MASM_p294_Instr(t.image, args, "masm [T3 =][uns(]Xmem[)], [uns(]Ymem[)], [ACx,] ACy"); 
                } // p.294
               ) { Main.fatal("masm error"); }

    | t=<MAX> (
               args = OPTsrc_dst() {
                   return m.make_MAX_p311_Instr(t.image, args, "max [src,] dst"); 
               } // p.311
               ) { Main.fatal("max error"); }


    | t=<MAXDIFF> (
                   args = ACx_ACy_ACz_ACw() {
                       return m.make_MAXDIFF_p315_Instr(t.image, args, "maxdiff ACx, ACy, ACz, ACw"); 
                   } // p.315
                   ) { Main.fatal("maxdiff error"); }


    | t=<DMAXDIFF> (
                    args = ACx_ACy_ACz_ACw_TRNx() {
                        return m.make_DMAXDIFF_p318_Instr(t.image, args, "dmaxdiff ACx, ACy, ACz, ACw, TRNx"); 
                    } // p.318
                   ) { Main.fatal("dmaxdiff error"); }


    | t=<MIN> (
               args = OPTsrc_dst() {
                   return m.make_MIN_p320_Instr(t.image, args, "min [src,] dst"); 
               } // p.320
               ) { Main.fatal("min error"); }


    | t=<MINDIFF> (
                   args = ACx_ACy_ACz_ACw() {
                       return m.make_MINDIFF_p324_Instr(t.image, args, "mindiff ACx, ACy, ACz, ACw"); 
                   } // p.324
                   ) { Main.fatal("mindiff error"); }

    | t=<DMINDIFF> (
                    args = ACx_ACy_ACz_ACw_TRNx() {
                        return m.make_DMINDIFF_p327_Instr(t.image, args, "dmindiff ACx, ACy, ACz, ACw, TRNx"); 
                    } // p.327
                   ) { Main.fatal("dmindiff error"); }


    | t=<MMAP> {
        return m.make_MMAP_p329_Instr(t.image, args, "mmap"); 
    } // mmap - used for Lmem and Smem ... p.329


    | t=<MOV> (
               LOOKAHEAD(P_XS16A_MOV_HASTY())
               args = P_XS16A_MOV_HASTY() {
                   return m.make_MOV_p413_Instr(t.image, args, "mov :: XS16A_MOV_HASTY"); 
               } // mov::mov

               |LOOKAHEAD(P_HASTY_MOV_XS16A())
               args = P_HASTY_MOV_XS16A() {
                   return m.make_MOV_p413_Instr(t.image, args, "mov :: HASTY_MOV_XS16A"); 
               } // mov::mov reverse

               |LOOKAHEAD(P_HASTY_SUB_XS16A())
               args = P_HASTY_SUB_XS16A() {
                   return m.make_SUB_p575_Instr(t.image, args, "mov :: HASTY_SUB_XS16A"); 
               } // sub::mov reverse

               |LOOKAHEAD(P_YS16A_MACM_OXTA())
               args = P_YS16A_MACM_OXTA() {
                   return m.make_MACM_p281_Instr(t.image, args, "mov :: YS16A_MACM_OXTA"); 
               } // macm::mov reverse

               |LOOKAHEAD(P_YS16A_MASM_OXTA())
               args = P_YS16A_MASM_OXTA() {
                   return m.make_MASM_p307_Instr(t.image, args, "mov :: YS16A_MASM_OXTA"); 
               } // masm::mov reverse

               |LOOKAHEAD(P_HASTY_ADD_XS16AA())
               args = P_HASTY_ADD_XS16AA() {
                   return m.make_ADD_p130_Instr(t.image, args, "mov :: HASTY_ADD_XS16AA");  // reverse add::mov
               } // add::mov reverse

               |LOOKAHEAD(P_HASTY_MACM_OXTA())
               args = P_HASTY_MACM_OXTA() {
                   return m.make_MACM_p283_Instr(t.image, args, "mov :: HASTY_MACM_OXTA"); 
               } // macm::mov reverse

               |LOOKAHEAD(P_HASTY_MASM_OXTA())
               args = P_HASTY_MASM_OXTA() {
                   return m.make_MASM_p309_Instr(t.image, args, "mov :: HASTY_MASM_OXTA"); 
               } // masm::mov reverse

               |LOOKAHEAD(P_HASTY_MPYM_OXTA())
               args = P_HASTY_MPYM_OXTA() {
                   return m.make_MPYM_p432_Instr(t.image, args, "mov :: HASTY_MPYM_OXTA"); 
               } // mpym::mov reverse

               |LOOKAHEAD(rnd_Smem_LSHIFT_Tx_ACx())
               args = rnd_Smem_LSHIFT_Tx_ACx() {
                   return m.make_MOV_p332_Instr(t.image, args, "mov [rnd(]Smem << Tx[)], ACx"); 
               }

               |LOOKAHEAD(low_byte_Smem_LSHIFT_SHIFTW_ACx())
               args = low_byte_Smem_LSHIFT_SHIFTW_ACx() {
                   return m.make_MOV_p333_Instr(t.image, args, "mov low_byte(Smem) << #SHIFTW, ACx"); 
               }

               |LOOKAHEAD(high_byte_Smem_LSHIFT_SHIFTW_ACx())
               args = high_byte_Smem_LSHIFT_SHIFTW_ACx() {
                   return m.make_MOV_p334_Instr(t.image, args, "mov high_byte(Smem) << #SHIFTW, ACx"); 
               }

               |LOOKAHEAD(Smem_LSHIFT_16_ACx())
               args = Smem_LSHIFT_16_ACx() {
                   return m.make_MOV_p335_Instr(t.image, args, "mov Smem << #16, ACx"); 
               }

               |LOOKAHEAD(unsSmem_ACx())
               args = unsSmem_ACx() {
                   return m.make_MOV_p336_Instr(t.image, args, "mov [uns(]Smem[)], ACx"); 
               } // p.336

               |LOOKAHEAD(unsSmem_LSHIFT_SHIFTW_ACx())
               args = unsSmem_LSHIFT_SHIFTW_ACx() {
                   return m.make_MOV_p337_Instr(t.image, args, "mov [uns(]Smem[)] << #SHIFTW, ACx"); 
               } // p.337

               |LOOKAHEAD(DBL_Lmem_ACx())
               args = DBL_Lmem_ACx() {
                   return m.make_MOV_p338_Instr(t.image, args, "mov dbl(Lmem), ACx"); 
               } // p.338

               |LOOKAHEAD(Xmem_Ymem_ACx())
               args = Xmem_Ymem_ACx() {
                   return m.make_MOV_p339_Instr(t.image, args, "mov Xmem, Ymem, ACx"); 
               } // p.339

               |LOOKAHEAD(DBL_Lmem_PAIR_HI_ACx())
               args = DBL_Lmem_PAIR_HI_ACx() {
                   return m.make_MOV_p341_Instr(t.image, args, "mov dbl(Lmem), pair(HI(ACx))"); 
               } // p.341

               |LOOKAHEAD(DBL_Lmem_PAIR_LO_ACx())
               args = DBL_Lmem_PAIR_LO_ACx() {
                   return m.make_MOV_p342_Instr(t.image, args, "mov dbl(Lmem), pair(LO(ACx))"); 
               } // p.342

               |LOOKAHEAD(K16_LSHIFT_16_ACx())
               args = K16_LSHIFT_16_ACx() {
                   return m.make_MOV_p344_Instr(t.image, args, "mov K16 << #16, ACx"); 
               } // p.344

               |LOOKAHEAD(K16_LSHIFT_SHFT_ACx())
               args = K16_LSHIFT_SHFT_ACx() {
                   return m.make_MOV_p345_Instr(t.image, args, "mov K16 << #SHFT, ACx"); 
               } // p.345

               |LOOKAHEAD(Smem_dst())
               args = Smem_dst() {
                   return m.make_MOV_p347_Instr(t.image, args, "mov Smem, dst"); 
               } // p.347

               |LOOKAHEAD(uns_high_byte_Smem_dst())
               args = uns_high_byte_Smem_dst() {
                   return m.make_MOV_p348_Instr(t.image, args, "[uns(]high_byte(Smem)[)], dst"); 
               } // p.348

               |LOOKAHEAD(uns_low_byte_Smem_dst())
               args = uns_low_byte_Smem_dst() {
                   return m.make_MOV_p350_Instr(t.image, args, "[uns(]low_byte(Smem)[)], dst"); 
               } // p.350

               |LOOKAHEAD(k4_k4K16_dst())
               args = k4_k4K16_dst() {
                   return m.make_MOV_p353_Instr(t.image, args, "mov ((-)?k4|K16), dst"); 
               } // p.353-5

               |LOOKAHEAD(DBL_Lmem_PAIR_TAx())
               args = DBL_Lmem_PAIR_TAx() {
                   return m.make_MOV_p356_Instr(t.image, args, "mov dbl(Lmem), pair(TAx)"); 
               } // p.356

               |LOOKAHEAD(Smem_REG19())
               args = Smem_REG19() {
                   return m.make_MOV_p359_Instr(t.image, args, "mov Smem, REG19"); 
               } // p.359

               |LOOKAHEAD(DBL_Lmem_RETA())
               args = DBL_Lmem_RETA() {
                   return m.make_MOV_p359_No20_Instr(t.image, args, "mov dbl(Lmem), RETA"); 
               } 

               |LOOKAHEAD(k12_REGLIST1())
               args = k12_REGLIST1() {
                   return m.make_MOV_p360_k12_Instr(t.image, args, "mov k12, REG6"); 
               } // p.360

               |LOOKAHEAD(k7_DPH())
               args = k7_DPH() {
                   return m.make_MOV_p360_k7_Instr(t.image, args, "mov k7, DPH"); 
               }
               |LOOKAHEAD(k9_PDP())
               args = k9_PDP() {
                   return m.make_MOV_p360_k9_Instr(t.image, args, "mov k9, PDP"); 
               }
               |LOOKAHEAD(k16_REG9())
               args = k16_REG9() {
                   return m.make_MOV_p360_k16_Instr(t.image, args, "mov k16, REG9"); 
               } // p.360

               |LOOKAHEAD(DBL_Lmem_XAdst())
               args = DBL_Lmem_XAdst() {
                   return m.make_MOV_p362_Instr(t.image, args, "mov dbl(Lmem), XAdst"); 
               } // p.362

               | args = K8K16_Smem() {
                   return m.make_MOV_p363_Instr(t.image, args, "mov K8|K16, Smem"); 
               } // p.363

               |LOOKAHEAD(HI_ACx_TAx())
               args = HI_ACx_TAx() {
                   return m.make_MOV_p364_Instr(t.image, args, "mov HI(ACx), TAx"); 
               } // p.364

               |LOOKAHEAD(src_dst())
               args = src_dst() {
                   return m.make_MOV_p365_Instr(t.image, args, "mov src, dst"); 
               }        // p.365

               |LOOKAHEAD(TAx_HI_ACx())
               args = TAx_HI_ACx() {
                   return m.make_MOV_p367_Instr(t.image, args, "mov TAx, HI(ACx)"); 
               } // p.367

               |LOOKAHEAD(TAx_REGLIST2())
               args = TAx_REGLIST2() {
                   return m.make_MOV_p368_Instr(t.image, args, "mov TAx, REG6"); 
               } // p.368

               |LOOKAHEAD(REGLIST3_TAx())
               args = REGLIST3_TAx() {
                   return m.make_MOV_p370_Instr(t.image, args, "mov REG6, TAx"); 
               } // p.370

               |LOOKAHEAD(xsrc_xdst())
               args = xsrc_xdst() {
                   return m.make_MOV_p372_Instr(t.image, args, "mov xsrc, xdst"); 
               } // p.372

               |LOOKAHEAD(Cmem_Smem())
               args = Cmem_Smem() {
                   return m.make_MOV_p374_Instr(t.image, args, "mov Cmem, Smem"); 
               } // p.374

               |LOOKAHEAD(Smem_Cmem())
               args = Smem_Cmem() {
                   return m.make_MOV_p375_Instr(t.image, args, "mov Smem, Cmem"); 
               } // p.375

               |LOOKAHEAD(Cmem_DBL_Lmem())
               args = Cmem_DBL_Lmem() {
                   return m.make_MOV_p376_Instr(t.image, args, "mov Cmem, dbl(Lmem)"); 
               } // p.376

               |LOOKAHEAD(DBL_Lmem_Cmem())
               args = DBL_Lmem_Cmem() {
                   return m.make_MOV_p377_Instr(t.image, args, "mov dbl(Lmem), Cmem"); 
               } // p.377

               | args = DBL_Xmem_DBL_Ymem() {
                   return m.make_MOV_p378_Instr(t.image, args, "mov dbl(Xmem), dbl(Ymem)"); 
               } // p.378

               |LOOKAHEAD(Xmem_Ymem())
               args = Xmem_Ymem() {
                   return m.make_MOV_p379_Instr(t.image, args, "mov Xmem, Ymem"); 
               } // p.379

               |LOOKAHEAD(HI_ACx_Smem())
               args = HI_ACx_Smem() {
                   return m.make_MOV_p382_Instr(t.image, args, "mov HI(ACx), Smem"); 
               } // p.382

               |LOOKAHEAD(rnd_HI_ACx_Smem())
               args = rnd_HI_ACx_Smem() {
                   return m.make_MOV_p383_Instr(t.image, args, "mov [rnd(]HI(ACx)[)], Smem"); 
               } // p.383

               |LOOKAHEAD(ACx_LSHIFT_Tx_Smem())
               args = ACx_LSHIFT_Tx_Smem() {
                   return m.make_MOV_p384_Instr(t.image, args, "mov ACx << Tx, Smem"); 
               } // p.384

               |LOOKAHEAD(rnd_HI_ACx_LSHIFT_Tx_Smem())
               args = rnd_HI_ACx_LSHIFT_Tx_Smem() {
                   return m.make_MOV_p385_Instr(t.image, args, "mov [rnd(]HI(ACx << Tx)[)], Smem"); 
               } // p.385

               |LOOKAHEAD(ACx_LSHIFT_SHIFTW_Smem())
               args = ACx_LSHIFT_SHIFTW_Smem() {
                   return m.make_MOV_p386_Instr(t.image, args, "mov ACx << #SHIFTW, Smem"); 
               } // p.386

               |LOOKAHEAD(HI_ACx_LSHIFT_SHIFTW_Smem())
               args = HI_ACx_LSHIFT_SHIFTW_Smem() {
                   return m.make_MOV_p387_Instr(t.image, args, "mov HI(ACx << #SHIFTW), Smem"); 
               } // p.387

               |LOOKAHEAD(rnd_HI_ACx_LSHIFT_SHIFTW_Smem())
               args = rnd_HI_ACx_LSHIFT_SHIFTW_Smem() {
                   return m.make_MOV_p388_Instr(t.image, args, "mov [rnd(]HI(ACx << #SHIFTW)[)], Smem"); 
               } // p.388

               |LOOKAHEAD(uns_rnd_HI_saturateACx_Smem())
               args = uns_rnd_HI_saturateACx_Smem() {
                   return m.make_MOV_p389_Instr(t.image, args, "mov [uns(][rnd(]HI[(saturate](ACx)[)))], Smem"); 
               } // p.389

               |LOOKAHEAD(uns_rnd_HI_saturateACxLSHIFT_Tx_Smem())
               args = uns_rnd_HI_saturateACxLSHIFT_Tx_Smem() {
                   return m.make_MOV_p391_Instr(t.image, args, "mov [uns(][rnd(]HI[(saturate](ACx << Tx)[)))], Smem"); 
               } // p.391

               |LOOKAHEAD(uns_rnd_HI_saturateACxLSHIFT_SHIFTW_Smem())
               args = uns_rnd_HI_saturateACxLSHIFT_SHIFTW_Smem() {
                   return m.make_MOV_p393_Instr(t.image, args, "mov [uns(][rnd(]HI[(saturate](ACx << #SHIFTW)[)))], Smem"); 
               } // p.393

               |LOOKAHEAD(ACx_DBL_Lmem())
               args = ACx_DBL_Lmem() {
                   return m.make_MOV_p395_Instr(t.image, args, "mov ACx, dbl(Lmem)"); 
               } // p.395

               | args = uns_SATURATE_ACx_DBL_Lmem() {
                   return m.make_MOV_p396_Instr(t.image, args, "mov [uns(]saturate(ACx)[)], dbl(Lmem)"); 
               } // p.396

               |LOOKAHEAD(ACx_RSHIFT_1_DUAL_Lmem())
               args = ACx_RSHIFT_1_DUAL_Lmem() {
                   return m.make_MOV_p398_Instr(t.image, args, "mov ACx >> #1, dual(Lmem)"); 
               } // p.398

               |LOOKAHEAD(ACx_Xmem_Ymem())
               args = ACx_Xmem_Ymem() {
                   return m.make_MOV_p399_Instr(t.image, args, "mov ACx, Xmem, Ymem"); 
               } // p.399

               |LOOKAHEAD(PAIR_HI_ACx_DBL_Lmem())
               args = PAIR_HI_ACx_DBL_Lmem() {
                   return m.make_MOV_p401_Instr(t.image, args, "mov pair(HI(ACx)), dbl(Lmem)"); 
               } // p.401

               |LOOKAHEAD(PAIR_LO_ACx_DBL_Lmem())
               args = PAIR_LO_ACx_DBL_Lmem() {
                   return m.make_MOV_p402_Instr(t.image, args, "mov pair(LO(ACx)), dbl(Lmem)"); 
               } // p.402

               |LOOKAHEAD(src_Smem())
               args = src_Smem() {
                   return m.make_MOV_p404_Instr(t.image, args, "mov src, Smem"); 
               } // p.404

               |LOOKAHEAD(src_high_byte_Smem())
               args = src_high_byte_Smem() {
                   return m.make_MOV_p405_Instr(t.image, args, "mov src, high_byte(Smem)"); 
               } // p.405

               | args = src_low_byte_Smem() {
                   return m.make_MOV_p406_Instr(t.image, args, "mov src, low_byte(Smem)"); 
               } // p.406

               | args = PAIR_TAx_DBL_Lmem() {
                   return m.make_MOV_p407_Instr(t.image, args, "mov pair(TAx), dbl(Lmem)"); 
               } // p.407

               | args = REG19_Smem() {
                   return m.make_MOV_p408_Instr(t.image, args, "mov REG19, Smem"); 
               } // p.408

               | args = RETA_DBL_Lmem() {
                   return m.make_MOV_p408_No20_Instr(t.image, args, "mov RETA, dbl(Lmem)"); 
               }
               | args = XAsrc_DBL_Lmem() {
                   return m.make_MOV_p412_Instr(t.image, args, "mov XAsrc, dbl(Lmem)"); 
               } // p.412
               ) { Main.fatal("mov error"); }


    | t=<MOV40> ( 
                 args = DBL_Lmem_ACx() {
                     return m.make_MOV40_p338_Instr(t.image, args, "mov40 dbl(Lmem), ACx"); 
                 } // p.338
                   ) { Main.fatal("mov40 error"); }


    | t=<MPY> (
               LOOKAHEAD(P_YCA_AMAR_Xmem())
               args = P_YCA_AMAR_Xmem() {
                   return m.make_AMAR_p157_Instr(t.image, args, "mpy :: YCA_AMAR_Xmem()"); 
               } // amar::mpy reverse

               |LOOKAHEAD(P_XCA_MAC_YCA16())
               args = P_XCA_MAC_YCA16() {
                   return m.make_MPY_p428_Instr(t.image, args, "mpy :: XCA_MAC_YCA16"); 
               } // mpy::mac

               |LOOKAHEAD(P_XCA_MAC_YCA())
               args = P_XCA_MAC_YCA() {
                   return m.make_MAC_p278_Instr(t.image, args, "mpy :: XCA_MAC_YCA"); 
               } // mac::mpy reverse

               |LOOKAHEAD(P_XCA_MAS_YCA())
               args = P_XCA_MAS_YCA() {
                   return m.make_MAS_p304_Instr(t.image, args, "mpy :: XCA_MAS_YCA"); 
               } // mas::mpy reverse

               |LOOKAHEAD(P_XCA_MPY_YCA())
               args = P_XCA_MPY_YCA() {
                   return m.make_MPY_p430_Instr(t.image, args, "mpy :: XCA_MPY_YCA"); 
               } // mpy::mpy

               | args = OPTACx_ACy() {
                   return m.make_MPY_p417_Instr(t.image, args, "mpy [ACx,] ACy"); 
               } // p.417

               | args = Tx_OPTACx_ACy() {
                   return m.make_MPY_p418_Instr(t.image, args, "mpy Tx, [ACx,] ACy"); 
               } // p.418
               ) { Main.fatal("mpy error"); }


    | t=<MPYK> (
                args = K8K16_OPTACx_ACy() {
                    return m.make_MPYK_p420_Instr(t.image, args, "mpyk K8|K16 [ACx,] ACy"); 
                } // p.420
                ) { Main.fatal("mpyk error"); }


    | t=<MPYM> (
                LOOKAHEAD(P_OXTA_MOV_HASTY())
                args = P_OXTA_MOV_HASTY() {
                    return m.make_MPYM_p432_Instr(t.image, args, "mpym :: OXTA_MOV_HASTY"); 
                } // mpym::mov

                |LOOKAHEAD(OPTT3EQ_Smem_Cmem_ACx())
                args = OPTT3EQ_Smem_Cmem_ACx() {
                    return m.make_MPYM_p421_Instr(t.image, args, "mpym [T3 =]Smem, Cmem, ACx"); 
                } // p.421

                |LOOKAHEAD(OPTT3EQ_Smem_OPTACx_ACy())
                args = OPTT3EQ_Smem_OPTACx_ACy() {
                    return m.make_MPYM_p423_Instr(t.image, args, "mpym [T3 =]Smem, [ACx,] ACy"); 
                } // p.423

                |LOOKAHEAD(OPTT3EQ_unsXmem_unsYmem_ACx())
                args = OPTT3EQ_unsXmem_unsYmem_ACx() {
                    return m.make_MPYM_p425_Instr(t.image, args, "mpym [T3 = ][uns(]Xmem[)], [uns(]Ymem[)], ACx"); 
                } //p.425

                |LOOKAHEAD(OPTT3EQ_Smem_Tx_ACx())
                args = OPTT3EQ_Smem_Tx_ACx() {
                    return m.make_MPYM_p427_Instr(t.image, args, "mpym [T3 = ]Smem, Tx, ACx"); 
                } // p.427
                ) { Main.fatal("mpym error"); }


    | t=<MPYMK> (
                 args = OPTT3EQ_Smem_K8_ACx() {
                     return m.make_MPYMK_p424_Instr(t.image, args, "mpymk [T3 =]Smem, K8, ACx"); 
                 } // p.424
                 ) { Main.fatal("mpymk error"); }


    | t=<NEG> (
               args = OPTsrc_dst() {
                   return m.make_NEG_p434_Instr(t.image, args, "neg [src,] dst"); 
               } // p.434
               ) { Main.fatal("neg error"); }


    | t=<NEXP> (
                args = P_AT_MANT_AA() {
                    return m.make_NEXP_p285_Instr(t.image, args, "nexp::mant"); 
                } // nexp::mant p.285
                ) { Main.fatal("nexp error"); }


    | t=<NOP> {
        return m.make_NOP_p436_Instr(t.image, args, "nop"); 
    } // p.436


    | t=<NOP_16> {
        return m.make_NOP16_p436_Instr(t.image, args, "nop_16"); 
    } // p.436


    | t=<NOT> (
               args = OPTsrc_dst() {
                   return m.make_NOT_p437_Instr(t.image, args, "not [src,] dst"); 
               } // p.437
               ) { Main.fatal("not error"); }


    | t=<OR> (
              LOOKAHEAD(k8k16_OPTsrc_dst())
              args = k8k16_OPTsrc_dst() {
                  return m.make_OR_p440_Instr(t.image, args, "or k8|k16, src, dst"); 
              } // p.440

              | args =  Smem_OPTsrc_dst() {
                  return m.make_OR_p442_Instr(t.image, args, "or Smem, src, dst"); 
              } // p.442

              | LOOKAHEAD(ACx_LSHIFT_SHIFTW_OPTACy())
              args = ACx_LSHIFT_SHIFTW_OPTACy() {
                  return m.make_OR_p443_Instr(t.image, args, "or ACx << #SHIFTW [,ACy]"); 
              } // p.443

              | LOOKAHEAD(k16_LSHIFT_16_OPTACx_ACy())
              args = k16_LSHIFT_16_OPTACx_ACy() {
                  return m.make_OR_p444_Instr(t.image, args, "or k16 << #16, [ACx,] ACy"); 
              } // p.444

              | LOOKAHEAD(k16_LSHIFT_SHFT_OPTACx_ACy())
              args = k16_LSHIFT_SHFT_OPTACx_ACy() {
                  return m.make_OR_p445_Instr(t.image, args, "or k16 << #SHFT, [ACx,] ACy"); 
              } // p.445

              | args =  k16_Smem() {
                  return m.make_OR_p446_Instr(t.image, args, "or k16, Smem"); 
              } // p.446

              | args =  OPTsrc_dst() {
                  return m.make_OR_p439_Instr(t.image, args, "or src, dst"); 
              } // p.439
              ) { Main.fatal("or error"); }

    
    // p.448
    | t=<POP> (
               LOOKAHEAD(dst1_dst2())
               args = dst1_dst2() {
                   return m.make_POP_p448_Instr(t.image, args, "pop dst, dst"); 
               } // p.448

               |LOOKAHEAD(dst_Smem())
               args = dst_Smem() {
                   return m.make_POP_p450_Instr(t.image, args, "pop dst, Smem"); 
               } // p.450

               | r = dst() {
                   args.add(r);
                   return m.make_POP_p449_Instr(t.image, args, "pop dst"); 
               } // p.449

               |LOOKAHEAD(DBL_ACx())
               r = DBL_ACx() {
                   args.add(r);
                   return m.make_POP_p451_Instr(t.image, args, "pop dbl(ACx)");
               } // p.451

               | ma = Smem() {
                   args.add(ma);
                   return m.make_POP_p452_Instr(t.image, args, "pop Smem");
               } // p.452

               | ma = DBL_Lmem() {
                   args.add(ma);
                   return m.make_POP_p453_Instr(t.image, args, "pop dbl(Lmem)");
               } // p.453
               ) { Main.fatal("pop error"); }

    // p.454
    | t=<POPBOTH> r = xdst() {
        args.add(r);
        return m.make_POPBOTH_p454_Instr(t.image, args, "popboth xdst"); 
    }


    // port() p.455 kps -todo


    // p.457
    | t=<PSH> (
               LOOKAHEAD(src1_src2())
               args = src1_src2() {
                   return m.make_PSH_p458_Instr(t.image, args, "psh src, src"); 
               } // p.458

               |LOOKAHEAD(src_Smem())
               args = src_Smem() {
                   return m.make_PSH_p460_Instr(t.image, args, "psh src, Smem"); 
               } // p.460

               | r = src() {
                   args.add(r);
                   return m.make_PSH_p459_Instr(t.image, args, "psh src"); 
               } // p.459

               |LOOKAHEAD(DBL_ACx())
               r = DBL_ACx() {
                   args.add(r);
                   return m.make_PSH_p461_Instr(t.image, args, "psh dbl(ACx)");
               } // p.461

               | ma = Smem() {
                   args.add(ma);
                   return m.make_PSH_p462_Instr(t.image, args, "psh Smem");
               } // p.462

               | ma = DBL_Lmem() {
                   args.add(ma);
                   return m.make_PSH_p463_Instr(t.image, args, "psh dbl(Lmem)");
               } // p.463
               ) { Main.fatal("psh error"); }


    // p.464
    | t=<PSHBOTH> r = xsrc() {
        args.add(r);
        return m.make_PSHBOTH_p464_Instr(t.image, args, "pshboth xsrc"); 
    }


    // p.465
    | t=<RESET> {
        return m.make_RESET_p465_Instr(t.image, args, "reset"); 
    }


    // p.469
    | t=<RET> {
        return m.make_RET_p469_Instr(t.image, args, "ret"); 
    }


    // p.471
    | t=<RETCC> (
                 cf = cond() {
                     args.add(cf);
                     return m.make_RETCC_p471_Instr(t.image, args, "retcc cond"); 
                 }
                 ) { Main.fatal("retcc error"); }


    // p.473
    | t=<RETI> {
        return m.make_RETI_p473_Instr(t.image, args, "reti"); 
    }


    // p.475
    | t=<ROL> (
               args = BitIn_src_BitOut_dst() {
                   return m.make_ROL_p475_Instr(t.image, args, "rol BitIn, src, BitOut, dst"); 
               }
               ) { Main.fatal("rol error"); }


    // p.477
    | t=<ROR> (
               args = BitIn_src_BitOut_dst() {
                   return m.make_ROR_p477_Instr(t.image, args, "ror BitIn, src, BitOut, dst"); 
               }
               ) { Main.fatal("ror error"); }
    

    // p.479
    | t=<ROUND> (
                 args = OPTACx_ACy() {
                     return m.make_ROUND_p479_Instr(t.image, args, "round [ACx,] ACy"); 
                 }
                 ) { Main.fatal("round error"); }


    | t=<RPT> (
               imm = k8k16() {
                   args.add(imm);
                   return m.make_RPT_p482_Instr(t.image, args, "rpt k8|k16"); 
               } // p.482
               | r = CSR() {
                   args.add(r);
                   return m.make_RPT_p484_Instr(t.image, args, "rpt csr"); 
               } // p.484
               ) { Main.fatal("rpt error"); }


    | t=<RPTADD> (
                  LOOKAHEAD(CSR_TAx())
                  args = CSR_TAx() {
                      return m.make_RPTADD_p487_Instr(t.image, args, "rptadd CSR, TAx"); 
                  } // p.487

                  | args = CSR_k4() {
                      return m.make_RPTADD_p488_Instr(t.image, args, "rptadd CSR, k4"); 
                  } // p.488
                  ) { Main.fatal("rptadd error"); }


    | t=<RPTBLOCAL> (
                     target = Address() {
                         args.add(target);
                         return m.make_RPTBLOCAL_p490_Instr(t.image, args, "rptblocal pmad"); 
                     } // p.490
                     ) { Main.fatal("rptblocal error"); }


    | t=<RPTB> (
                target = Address() {
                    args.add(target);
                    return m.make_RPTB_p497_Instr(t.image, args, "rptb pmad"); 
                } // p.497
                ) { Main.fatal("rptb error"); }


    | t=<RPTCC> (
                 args = k8_cond() {
                     return m.make_RPTCC_p500_Instr(t.image, args, "rptcc k8, cond"); 
                 } // p.500
                 ) { Main.fatal("rptcc error"); }


    | t=<RPTSUB> (
                  args = CSR_k4() {
                      return m.make_RPTSUB_p503_Instr(t.image, args, "rptsub csr, k4"); 
                  } // p.503
                 ) { Main.fatal("rptcc error"); }


    | t=<SAT> (
               args = OPTACx_ACy() {
                   return m.make_SAT_p505_Instr(t.image, args, "sat [ACx,] ACy"); 
               } // p.505
               ) { Main.fatal("sat error"); }


    | t=<SFTCC> (
                 args = ACx_TCx() {
                     return m.make_SFTCC_p507_Instr(t.image, args, "sftcc ACx, TCx"); 
                 } // p.507
                 )  { Main.fatal("sftcc error"); }


    | t=<SFTL> (
                LOOKAHEAD(ACx_Tx_OPTACy())
                args = ACx_Tx_OPTACy() {
                    return m.make_SFTL_p510_Instr(t.image, args, "sftl ACx, Tx[, ACy]"); 
                } // p.510
                |LOOKAHEAD(ACx_SHIFTW_OPTACy())
                args = ACx_SHIFTW_OPTACy() {
                    return m.make_SFTL_p511_Instr(t.image, args, "sftl ACx, #SHIFTW[, ACy]"); 
                } // p.511
                | args = dst_1() {
                    return m.make_SFTL_p513_Instr(t.image, args, "sftl dst, #(-)?1"); 
                } // p.513,4
                ) { Main.fatal("sftl error"); }


    | t=<SFTS> (
                LOOKAHEAD(ACx_Tx_OPTACy())
                args = ACx_Tx_OPTACy() {
                    return m.make_SFTS_p516_Instr(t.image, args, "sfts ACx, Tx[, ACy]"); 
                } // p.516
                |LOOKAHEAD(ACx_SHIFTW_OPTACy())
                args = ACx_SHIFTW_OPTACy() {
                    return m.make_SFTS_p520_Instr(t.image, args, "sfts ACx, #SHIFTW[, ACy]"); 
                } // p.520
                | args = dst_1() {
                    return m.make_SFTS_p525_Instr(t.image, args, "sfts dst, #(-)1"); 
                } // p.525,7
                ) { Main.fatal("sfts error"); }


    | t=<SFTSC> (
                LOOKAHEAD(ACx_Tx_OPTACy())
                args = ACx_Tx_OPTACy() {
                    return m.make_SFTSC_p518_Instr(t.image, args, "sfts ACx, Tx[, ACy]"); 
                } // p.518
                | args = ACx_SHIFTW_OPTACy() {
                    return m.make_SFTSC_p522_Instr(t.image, args, "sftsc ACx, #SHIFTW[, ACy]"); 
                } // p.522
                ) { Main.fatal("sftsc error"); }

    | t=<SIM_TRIG> {
        return m.make_UNKNOWN_Instr(t.image, args, "sim_trig");  // 
    }

    | t=<SQA> (
               args = OPTACx_ACy() {
                   return m.make_SQA_p530_Instr(t.image, args, "sqa [ACx, ]ACy"); 
               } // p.530
               ) { Main.fatal("sqa error"); }


    | t=<SQAM> (
                args = OPTT3EQ_Smem_OPTACx_ACy() {
                    return m.make_SQAM_p531_Instr(t.image, args, "sqam [T3 = ]Smem, [ACx,] ACy"); 
                } // p.531
                ) { Main.fatal("sqam error"); }


    | t=<SQDST> (
                 args = Xmem_Ymem_ACx_ACy() {
                     return m.make_SQDST_p532_Instr(t.image, args, "sqdst Xmem, Ymem, ACx, ACy"); 
                 } // p.532
                 ) { Main.fatal("sqdst error"); }


    | t=<SQR> (
               args = OPTACx_ACy() {
                   return m.make_SQR_p535_Instr(t.image, args, "sqr [ACx, ]ACy"); 
               } // p.535
               ) { Main.fatal("sqr error"); }


    | t=<SQRM> (
                args = OPTT3EQ_Smem_ACx() {
                    return m.make_SQRM_p536_Instr(t.image, args, "sqrm [T3 = ]Smem, ACx"); 
                } // p.536
                ) { Main.fatal("sqrm error"); }


    | t=<SQS> (
               args = OPTACx_ACy() {
                   return m.make_SQS_p538_Instr(t.image, args, "sqs [ACx, ]ACy"); 
               } // p.538
               ) { Main.fatal("sqs error"); }

    
    | t=<SQSM> (
                args = OPTT3EQ_Smem_OPTACx_ACy() {
                    return m.make_SQSM_p539_Instr(t.image, args, "sqsm [T3 = ]Smem, [ACx, ]ACy"); 
                } // p.539
                ) { Main.fatal("sqsm error"); }


    | t=<SUB> (
               LOOKAHEAD(P_XS16AA_MOV_HASTY())
               args = P_XS16AA_MOV_HASTY() {
                   return m.make_SUB_p575_Instr(t.image, args, "sub :: XS16AA_MOV_HASTY"); 
               } // sub::mov

               | LOOKAHEAD(ACx_DBL_Lmem_ACy())
               args = ACx_DBL_Lmem_ACy() {
                   return m.make_SUB_p573_Instr(t.image, args, "sub ACx, dbl(Lmem), ACy"); 
               } // p.573

               | LOOKAHEAD(DUAL_Lmem_OPTACx_ACy())
               args = DUAL_Lmem_OPTACx_ACy() {
                   return m.make_SUB_p541_Instr(t.image, args, "sub dual(Lmem), [ACx, ]ACy"); 
               } // p.541 (typo on page)

               | LOOKAHEAD(ACx_DUAL_Lmem_ACy())
               args = ACx_DUAL_Lmem_ACy() {
                   return m.make_SUB_p543_Instr(t.image, args, "sub ACx, dual(Lmem), ACy"); 
               } // p.543

               | LOOKAHEAD(DUAL_Lmem_Tx_ACx())
               args = DUAL_Lmem_Tx_ACx() {
                   return m.make_SUB_p545_Instr(t.image, args, "sub dual(Lmem), Tx, ACx"); 
               } // p.545

               | LOOKAHEAD(Tx_DUAL_Lmem_ACx())
               args = Tx_DUAL_Lmem_ACx() {
                   return m.make_SUB_p547_Instr(t.image, args, "sub Tx, dual(Lmem), ACx"); 
               } // p.547

               | LOOKAHEAD(k4K16_OPTsrc_dst())
               args = k4K16_OPTsrc_dst() {
                   return m.make_SUB_p552_Instr(t.image, args, "sub k4|K16, [src,], dst"); 
               } // p.552,4

               | LOOKAHEAD(Smem_OPTsrc_dst())
               args = Smem_OPTsrc_dst() {
                   return m.make_SUB_p556_Instr(t.image, args, "sub Smem, [src,], dst"); 
               } // p.556

               | LOOKAHEAD(src_Smem_dst())
               args = src_Smem_dst() {
                   return m.make_SUB_p558_Instr(t.image, args, "sub src, Smem, dst"); 
               } // p.558

               | LOOKAHEAD(ACx_LSHIFT_Tx_ACy())
               args = ACx_LSHIFT_Tx_ACy() {
                   return m.make_SUB_p560_Instr(t.image, args, "sub ACx << Tx, ACy"); 
               } // p.560

               | LOOKAHEAD(ACx_LSHIFT_SHIFTW_ACy())
               args = ACx_LSHIFT_SHIFTW_ACy() {
                   return m.make_SUB_p561_Instr(t.image, args, "sub ACx << #SHIFTW, ACy"); 
               } // p.561

               | LOOKAHEAD(K16_LSHIFT_16_OPTACx_ACy())
               args = K16_LSHIFT_16_OPTACx_ACy() {
                   return m.make_SUB_p562_Instr(t.image, args, "sub K16 << #16, [ACx, ]ACy"); 
               } // p.562

               |LOOKAHEAD(K16_LSHIFT_SHFT_OPTACx_ACy())
               args = K16_LSHIFT_SHFT_OPTACx_ACy() {
                   return m.make_SUB_p563_Instr(t.image, args, "sub K16 << #SHFT, [ACx, ]ACy"); 
               } // p.563

               |LOOKAHEAD(Smem_LSHIFT_Tx_OPTACx_ACy())
               args = Smem_LSHIFT_Tx_OPTACx_ACy() {
                   return m.make_SUB_p564_Instr(t.image, args, "sub Smem << Tx, [ACx, ]ACy"); 
               } // p.564

               |LOOKAHEAD(ACx_Smem_LSHIFT_16_ACy())
               args = ACx_Smem_LSHIFT_16_ACy() {
                   return m.make_SUB_p566_Instr(t.image, args, "sub ACx, Smem << #16, ACy"); 
               } // p.566

               |LOOKAHEAD(unsSmem_BORROW_OPTACx_ACy())
               args = unsSmem_BORROW_OPTACx_ACy() {
                   return m.make_SUB_p567_Instr(t.image, args, "sub [uns(]Smem[)], BORROW, [ACx, ]ACy"); 
               } // p.567

               |LOOKAHEAD(unsSmem_OPTACx_ACy())
               args = unsSmem_OPTACx_ACy() {
                   return m.make_SUB_p569_Instr(t.image, args, "sub [uns(]Smem[)], [ACx, ]ACy"); 
               } // p.569

               |LOOKAHEAD(unsSmem_LSHIFT_SHIFTW_OPTACx_ACy())
               args = unsSmem_LSHIFT_SHIFTW_OPTACx_ACy() {
                   return m.make_SUB_p570_Instr(t.image, args, "sub [uns(]Smem[)] << #SHIFTW, [ACx, ]ACy"); 
               } //p.570

               |LOOKAHEAD(Smem_LSHIFT_16_OPTACx_ACy())
               args = Smem_LSHIFT_16_OPTACx_ACy() {
                   return m.make_SUB_p565_Instr(t.image, args, "sub Smem << #16, [ACx, ]ACy"); 
               } // p.565

               | args = DBL_Lmem_OPTACx_ACy() {
                   return m.make_SUB_p572_Instr(t.image, args, "sub dbl(Lmem), [ACx, ]ACy"); 
               } // p.572

               |LOOKAHEAD(Xmem_Ymem_ACx())
               args = Xmem_Ymem_ACx() {
                   return m.make_SUB_p574_Instr(t.image, args, "sub Xmem, Ymem, ACx"); 
               } // p.574

               | args = OPTsrc_dst() {
                   return m.make_SUB_p551_Instr(t.image, args, "sub [src,] dst"); 
               } // p.551

               | args =  K16_Smem() {
                   return m.make_SUB_xxx_Instr(t.image, args, "sub K16, Smem"); 
               } // doesn't exist, really an add instruction; example:  SUB #1, *SP(#12)
               ) { Main.fatal("sub error"); }

    | t=<SUBB> (
               args = unsSmem_OPTACx_ACy() {
                   return m.make_SUB_p567_Instr(t.image, args, "subb [uns(]Smem[)], [ACx, ]ACy"); 
               } // p.567
               ) { Main.fatal("subb error"); }

    | t=<SUBADD> (
                  LOOKAHEAD(Tx_Smem_ACx())
                  args = Tx_Smem_ACx() {
                      return m.make_SUBADD_p578_Instr(t.image, args, "subadd Tx, Smem, ACx"); 
                  } // p.578

                  | args = Tx_DUAL_Lmem_ACx() {
                      return m.make_SUBADD_p580_Instr(t.image, args, "subadd Tx, dual(Lmem), ACx"); 
                  } // p.580
                  ) { Main.fatal("subadd error"); }

    | t=<SUBC> (
                args = Smem_OPTACx_ACy() {
                    return m.make_SUBC_p582_Instr(t.image, args, "subc Smem, [ACx, ]ACy"); 
                } // p.582
                ) { Main.fatal("subc error"); }

    | t=<SWAP> (
                LOOKAHEAD(SwapOps())
                args = SwapOps() {
                    return m.make_SWAP_p585_Instr(t.image, args, "swap ..."); 
                } // p.585, 633
                |LOOKAHEAD(SwappOps())
                args = SwappOps() {
                    return m.make_SWAPP_p590_Instr(t.image, args, "swapp ..."); 
                } // p.590
                |args = Swap4Ops() {
                    return m.make_SWAP4_p595_Instr(t.image, args, "swap4 ..."); 
                } // p.595
                ) { Main.fatal("swap error"); }

    //    | t=<SWAPP> (
    //                 args = SwappOps() {
    //                     return m.make_SWAPP_p590_Instr(t.image, args, "swapp ..."); 
    //                 } // p.590
    //                 ) { Main.fatal("swapp error"); }
    //
//    | t=<SWAP4> (
//                 args = Swap4Ops() {
//                     return m.make_SWAP4_p595_Instr(t.image, args, "swap4 ..."); 
//                 } // p.595
//                 ) { Main.fatal("swap4 error"); }
    | t=<TRAP> (
                imm = k5() {
                    args.add(imm);
                    return m.make_TRAP_p597_Instr(t.image, args, "trap k5"); 
                } // p.597
                ) { Main.fatal("trap error"); }

    | t=<XCC> (
               args = OPTlabel_cond() {
                   return m.make_XCC_p600_Instr(t.image, args, "xcc [label, ]cond"); 
               } // p.600
               ) { Main.fatal("xcc error"); }

    | t=<XCCPART> (
                   args = OPTlabel_cond() {
                       return m.make_XCCPART_p603_Instr(t.image, args, "xccpart [label, ]cond"); 
                   } // p.603
               ) { Main.fatal("xcc error"); }

    | t=<XOR> (
               LOOKAHEAD(k8k16_OPTsrc_dst())
               args = k8k16_OPTsrc_dst() {
                   return m.make_XOR_p608_Instr(t.image, args, "xor k8|k16, src, dst"); 
               } // p.608

               | args =  Smem_OPTsrc_dst() {
                   return m.make_XOR_p610_Instr(t.image, args, "xor Smem, src, dst"); 
               } // p.610

               | LOOKAHEAD(ACx_LSHIFT_SHIFTW_OPTACy())
               args = ACx_LSHIFT_SHIFTW_OPTACy() {
                   return m.make_XOR_p611_Instr(t.image, args, "xor ACx << #SHIFTW [,ACy]"); 
               } // p.611

               | LOOKAHEAD(k16_LSHIFT_16_OPTACx_ACy())
               args = k16_LSHIFT_16_OPTACx_ACy() {
                   return m.make_XOR_p612_Instr(t.image, args, "xor k16 << #16, [ACx,] ACy"); 
               } // p.612

               | LOOKAHEAD(k16_LSHIFT_SHFT_OPTACx_ACy())
               args = k16_LSHIFT_SHFT_OPTACx_ACy() {
                   return m.make_XOR_p613_Instr(t.image, args, "xor k16 << #SHFT, [ACx,] ACy"); 
               } // p.613

               | args =  k16_Smem() {
                   return m.make_XOR_p614_Instr(t.image, args, "xor k16, Smem"); 
               } // p.614

               | args =  OPTsrc_dst() {
                   return m.make_XOR_p607_Instr(t.image, args, "xor src, dst"); 
               } // p.607
               ) { Main.fatal("xor error"); }



}



Label Label() :
{
    String s;
    Label l;
    Token t;
}
{
    t=<ID> {
        //if (t.beginColumn != 1) {
        //    Main.fatal("Label '" +t.image+"' on line " + t.beginLine
        //               + " must be on column 1!!!");
        //}
        
        s = t.image;
        //if (s.startsWith(".L")) {
        //    s = s + "(" + filename + ")";
        //}
        l = new Label(s, input);
        l.setInput(input);
        l.setLine(t.beginLine);
        return l;
    }

}

// --- Expressions --------------------------------------------------
// ALTUG p.84
// Appel p.46

ArrayList ExprList() :
{
    ArrayList list = new ArrayList();
    Expression expr1, expr2;
}
{
    expr1 = Expr() {
        list.add(expr1);
    }
    (<COMMA> expr2 = Expr() {
        list.add(expr2);
    }
     )* {
        return list;
    }
}

Expression Expr() :
{
    Expression expr;
    Token t;
}
{
    expr = expression() {
        //System.out.println("jj: FOUND expression '" + expr + "' == " + expr.evaluate(null));
        return expr;
    }
}


Expression expression() :
{
    Expression expr;
}
{
    expr = additive_expression() {
        //System.out.println("jj: expression got inclusive or expression '" + expr + "'");        
        return expr;
    }
}

Expression additive_expression() :
{
    ArrayList list = new ArrayList();
    Expression expr1, expr2;
    Token t;
}
{
    expr1 = multiplicative_expression() {
        list.add(expr1);
    }
    (LOOKAHEAD(3) ( t=<PLUS> | t=<MINUS>) expr2 = multiplicative_expression() {
        list.add(t.image);
        list.add(expr2);
    }
     )* {
        Expression lx = (Expression)list.remove(0);
        while (list.size() > 0) {
            String oper = (String)list.remove(0);
            Expression rx = (Expression)list.remove(0);
            lx = new BinaryExpression(lx, oper, rx);
        }
        return lx;
    }
}

Expression multiplicative_expression() :
{
    ArrayList list = new ArrayList();
    Expression expr1, expr2;
    Token t;
}
{
    expr1 = unary_expression() {
        list.add(expr1);
    }
    ((t=<STAR>|t=<SLASH>|t=<PERCENT>) expr2 = unary_expression() {
        list.add(t.image);
        list.add(expr2);
    }
     )* {
        Expression lx = (Expression)list.remove(0);
        while (list.size() > 0) {
            String oper = (String)list.remove(0);
            Expression rx = (Expression)list.remove(0);
            lx = new BinaryExpression(lx, oper, rx);
        }
        return lx;
    }
}

String unary_operator() :
{
    Token t;
}
{
    (t=<PLUS>|t=<MINUS>|t=<TILDE>|t=<BANG>) {
        return t.image;
    }
}

Expression unary_expression() :
{
    Expression expr;
    String oper = null;
}
{
    oper = unary_operator() expr = unary_expression() {
        return new UnaryExpression(oper, expr);
    }
    | expr = primary_expression() {
        return expr;
    }
}


Expression primary_expression() :
{
    Expression expr;
    String id;
    long num;
}
{
    <LPAREN> expr = expression() <RPAREN> {
        return new ParenthesisExpression(expr);
    }
    | id = Id() {
        return new IdExpression(id);
    }
    | num = Num() {
        return new NumExpression(num);
    }
}

String Id() :
{
    Token t;
}
{
    t = <ID> {
        //System.out.println("jj: saw id " + t.image);
        return t.image;
    }
}

long Num() :
{
    Token t;
    long value;
}
{
    t = <NUM> {
        value = parseNum(t.image);
        //System.out.println("jj: value of " + t.image + " is " + value);
        return value;
    }
}

// hexadecimal with no prefix, e.g. "00000a"
// or perhaps "Section" or a section name
String Hexhack() :
{
    Token t;
}
{
    t = <HEXHACK> {
        return t.image;
    }
}
// --- Expressions end ----------------------------------------------


String QuotedString() :
{
    Token t;
}
{
    t = <QUOTED_STRING> {
        return t.image.substring(1, t.image.length()-1);
    }
}
